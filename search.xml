<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[应用题(1)]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%BA%94%E7%94%A8%E9%A2%98-1%2F</url>
    <content type="text"><![CDATA[大家一起来思考一个问题：场景：1亿个用户，用户有频繁登录的，也有不经常登录的，每个用户登录，记为今天活跃，否则记为不活跃。问题一：如何来记录用户登录信息。问题二：如何来查询活跃用户(每周评出: 有奖活跃用户: 连续7天登录)。 思路一:|Userid|dt |active||:—:|:—:|:—:||1|2018-02-06|1||2|2018-02-06|0||3|2018-02-06|0||4|2018-02-06|1| 如果是放在表中, 结果1:表急剧增大,2:要用group ,sum运算,计算较慢 思路二：位图法 bit-maplog0206: ‘011001……………0’log0207: ‘010010……………1’log0208 : ‘011001……………0’log0209 : ‘011000……………1’…… 记录用户登陆:每天按日期生成一个位图, 用户登陆后,把user_id位上的bit值置为1 如何来查询活跃用户把1周的位图 and 计算, 位上为1的,即是连续登陆的用户。 1234567891011121314151617181920212223242526redis 127.0.0.1:6379&gt; setbit mon 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit mon 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit mon 5 1(integer) 0redis 127.0.0.1:6379&gt; setbit mon 7 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit thur 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 5 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 8 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit wen 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 4 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 6 1(integer) 0redis 127.0.0.1:6379&gt; bitop and res mon thur wen(integer) 12500001 如上例,优点: 节约空间, 1亿人每天的登陆情况,用1亿bit,约1200WByte,约10M 的字符就能表示 计算方便]]></content>
      <categories>
        <category>应用题</category>
      </categories>
      <tags>
        <tag>应用题| redis应用 | 位图应用 | 应用题1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis对于List链表的操作(第四部分)]]></title>
    <url>%2F2018%2F02%2F06%2Fredis%E5%AF%B9%E4%BA%8Elist%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C(%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86)%2F</url>
    <content type="text"><![CDATA[L代表左边头 R代表右边尾1lpush key value 作用: 把值插入到链表头部。1rpop key 作用: 返回并删除链表尾元素。rpush,lpop: 不解释1lrange key start stop 作用: 返回链表中[start ,stop]中的元素。规律: 左数从0开始,右数从-1开始1lrem key count value 作用: 从key链表中删除 value值。注: 删除绝对值count个值为value后结束Count&gt;0 从表头删除Count&lt;0 从表尾删除 1ltrim key start stop 作用: 剪切key对应的链表,切[start,stop]一段,并把该段重新赋给。key。1lindex key index 作用: 返回index索引上的值。如 lindex key 21llen key 作用:计算链表的元素个数。12redis 127.0.0.1:6379&gt; llen task(integer) 3 1linsert key after|before search value 作用: 在key链表中寻找’search’,并在search值之前|之后,插入value注: 一旦找到一个search(如果有多个值，找到第一个)后,命令就结束了,因此不会插入多个value。 重要1rpoplpush source dest 作用: 把source的尾部拿出,放在dest的头部,并返回该单元值。场景: task + bak 双链表完成安全队列。业务逻辑: Rpoplpush task bak； 接收返回值,并做业务处理； 如果成功,rpop bak 清除任务。 如不成功,下次从bak表里取任务。 1brpop | blpop key timeout 作用:等待弹出key的尾/头元素。Timeout为等待超时时间如果timeout为0,则一直等待 场景: 长轮询Ajax,在线聊天时,能够用到。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>教程| redis教程 | redis对于list链表的操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis对于String的操作(第三部分)]]></title>
    <url>%2F2018%2F02%2F06%2Fredis%E5%AF%B9%E4%BA%8EString%E7%9A%84%E6%93%8D%E4%BD%9C(%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86)%2F</url>
    <content type="text"><![CDATA[1set key value [ex 秒数] / [px 毫秒数] [nx] /[xx] 如: set a 1 ex 10 , 设置a的有效期为10秒 set a 1 px 9000 , 设置a的有效期为9秒(9000毫秒)注: 如果ex,px同时写,以px有效期为准如 set a 1 ex 100 px 9000, a的实际有效期是9000毫秒nx: 表示key不存在时,执行操作xx: 表示key必须存在时,执行操作1mset multi set 一次性设置多个键值例: mset key1 v1 key2 v2 ….1get key 作用:获取key的值1mget key1 key2 ..keyn 作用:获取多个key的值1setrange key offset value 作用:把字符串的offset偏移字节,改成value123456redis 127.0.0.1:6379&gt; set greet helloOKredis 127.0.0.1:6379&gt; setrange greet 2 ??(integer) 5redis 127.0.0.1:6379&gt; get greet&quot;he??o&quot; 注意: 如果偏移量&gt;字符长度, 该字符自动补0x001234redis 127.0.0.1:6379&gt; setrange greet 6 !(integer) 7redis 127.0.0.1:6379&gt; get greet&quot;heyyo\x00!&quot; 1append key value 作用: 把value追加到key的原值上1234567getrange key start stopredis 127.0.0.1:6379&gt; set title &apos;chinese&apos;OKredis 127.0.0.1:6379&gt; getrange title 0 3&quot;chin&quot;redis 127.0.0.1:6379&gt; getrange title 1 -2&quot;hines&quot; 作用: 是获取字符串中 [start, stop]范围的值注意: 对于字符串的下标,左数从0开始,右数从-1开始 start&gt;=length, 则返回空字符串 stop&gt;=length,则截取至字符结尾 如果start 所处位置在stop右边, 返回空字符串 1234567getset key newvalueredis 127.0.0.1:6379&gt; set cnt 0OKredis 127.0.0.1:6379&gt; getset cnt 1&quot;0&quot;redis 127.0.0.1:6379&gt; getset cnt 2&quot;1&quot; 作用: 获取并返回旧值,设置新值1incr key 作用: 指定的key的值加1,并返回加1后的值注意： 不存在的key当成0,再incr操作 范围为64有符号 123incrby key numberredis 127.0.0.1:6379&gt; incrby age 90(integer) 92 作用: 指定的key的值加number,并返回加number后的值123incrbyfloat key floatnumberredis 127.0.0.1:6379&gt; incrbyfloat age 3.5&quot;95.5&quot; 作用: 指定的key的值加浮点数,并返回加浮点数后的值12345678decr keyredis 127.0.0.1:6379&gt; set age 20OKredis 127.0.0.1:6379&gt; decr age(integer) 19decrby key numberredis 127.0.0.1:6379&gt; decrby age 3(integer) 16 作用：和incr，incrby正好相反，这里不再多说。123456789getbit key offsetredis 127.0.0.1:6379&gt; set char AOKredis 127.0.0.1:6379&gt; getbit char 1(integer) 1redis 127.0.0.1:6379&gt; getbit char 2(integer) 0redis 127.0.0.1:6379&gt; getbit char 7(integer) 1 作用:获取值的二进制表示,对应位上的值(从左,从0编号)。1setbit key offset value 作用：设置offset对应二进制位上的值返回: 该位上的旧值注意: 如果offset过大,则会在中间填充0, offset最大大到多少 offset最大2^32-1,可推出最大的的字符串为512M 1bitop operation destkey key1 [key2 ...] 对key1,key2..keyN作operation,并将结果保存到 destkey 上。operation 可以是 AND 、 OR 、 NOT 、 XOR1234567891011121314redis 127.0.0.1:6379&gt; setbit lower 7 0(integer) 0redis 127.0.0.1:6379&gt; setbit lower 2 1(integer) 0redis 127.0.0.1:6379&gt; get lower&quot; &quot;redis 127.0.0.1:6379&gt; set char QOKredis 127.0.0.1:6379&gt; get char&quot;Q&quot;redis 127.0.0.1:6379&gt; bitop or char char lower(integer) 1redis 127.0.0.1:6379&gt; get char&quot;q&quot; 注意: 对于NOT操作, key不能多个]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>教程| redis教程 | redis对于String的操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis对于key的通用操作(第二部分)]]></title>
    <url>%2F2018%2F02%2F05%2Fredis%E5%AF%B9%E4%BA%8Ekey%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C(%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86)%2F</url>
    <content type="text"><![CDATA[1del key1 key2 ... Keyn 作用:删除1个或多个键返回值: 不存在的key忽略掉,返回真正删除的key的数量1rename key newkey 作用: 给key赋一个新的key名注:如果newkey已存在,则newkey的原值被覆盖1renamenx key newkey 作用: 把key改名为newkey返回值: 发生修改返回1,未发生修改返回0注: nx–&gt; not exists, 即, newkey不存在时,作改名动作1move key db 12345678910111213141516171819redis 127.0.0.1:6379[1]&gt; select 2OKredis 127.0.0.1:6379[2]&gt; keys *(empty list or set)redis 127.0.0.1:6379[2]&gt; select 0OKredis 127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;cc&quot;3) &quot;a&quot;4) &quot;b&quot;redis 127.0.0.1:6379&gt; move cc 2(integer) 1redis 127.0.0.1:6379&gt; select 2OKredis 127.0.0.1:6379[2]&gt; keys *1) &quot;cc&quot;redis 127.0.0.1:6379[2]&gt; get cc&quot;3&quot; (注意: 一个redis进程,打开了不止一个数据库, 默认打开16个数据库,从0到15编号,如果想打开更多数据库,可以从配置文件修改)1keys pattern 作用:查询相应的key在redis里,允许模糊查询key,有3个通配符 *, ? ,[] *: 通配任意多个字符 ?: 通配单个字符 []: 通配括号内的某1个字符 12345678910111213141516171819redis 127.0.0.1:6379&gt; flushdbOKredis 127.0.0.1:6379&gt; keys *(empty list or set)redis 127.0.0.1:6379&gt; mset one 1 two 2 three 3 four 4OKredis 127.0.0.1:6379&gt; keys o*1) &quot;one&quot;redis 127.0.0.1:6379&gt; keys *o1) &quot;two&quot;redis 127.0.0.1:6379&gt; keys ???1) &quot;one&quot;2) &quot;two&quot;redis 127.0.0.1:6379&gt; keys on?1) &quot;one&quot;redis 127.0.0.1:6379&gt; set ons yesOKredis 127.0.0.1:6379&gt; keys on[eaw]1) &quot;one&quot; 1randomkey 作用:返回随机key1exists key 作用:判断key是否存在,返回1(存在)/0(不存在)1type key 作用:返回key存储的值的类型有string,link,set,order set, hash1ttl key 作用: 查询key的生命周期返回: 秒数注:对于不存在的key或已过期的key,返回-2 对于存在的key,返回-11expire key 整型值 作用: 设置key的生命周期,以秒为单位同理:pexpire key 毫秒数, 设置生命周期pttl key, 以毫秒返回生命周期 1persist key 作用: 把指定key置为永久有效]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>教程| redis教程 | redis对于key的通用操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis的特点及安装(第一部分)]]></title>
    <url>%2F2018%2F02%2F05%2Fredis%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E5%AE%89%E8%A3%85(%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86)%2F</url>
    <content type="text"><![CDATA[前言2017年已经接近尾声，最近自己在慧与实习(原惠普)也没啥事，闲暇之余，想起自己已经好久没有写博客，决定把redis的博客稍微写一写，相当于做一份笔记，以后方便查阅。 redis是啥呢redis的官方站点 Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. redis是开源(BSD许可),内存数据结构存储.可以当作数据库，缓存和信息代理使用。它支持的数据结构服务，有字符串、哈希表、列表、集合、有序集合范围查询，位图，hyperloglogs和半径查询地理信息的索引。 redis和memcached的简单比较redis和memcached相比,独特之处: redis可以用来做存储(storge)和缓存(cache), 而memcached只可以用来做缓存(cache)。这个特点主要因为其有”持久化”的功能.持久化简单一句话就是内存里面数据可以同步到光盘或硬盘等长久可以存储的设备上面。 存储的数据有”结构”,对于memcached来说,存储的数据,只有1种类型–”字符串”,而redis则可以存储字符串,链表,哈希结构,集合,有序集合. redis下载安装 官方站点: redis.io 下载最新版或者最新stable版 解压源码并进入目录 不用configure(生成makefile) 直接make 编译(如果是32位机器 make 32bit;时间问题见末尾) 可选步骤: make test 测试编译情况(可能出现: need tcl &gt;8.4这种情况, yum install tcl) make install安装到指定的目录 12345$ wget http://download.redis.io/releases/redis-4.0.8.tar.gz$ tar xzf redis-4.0.8.tar.gz$ cd redis-4.0.8$ make$ make PREFIX=/home/centos/redis/anzhuang install 注: PREFIX要大写 make install之后,得到如下几个文件 12345redis-benchmark 性能测试工具redis-check-aof 日志文件检测工具(比如断电造成日志损坏,可以检测并修复)redis-check-dump 快照文件检测工具,效果类上redis-cli 客户端redis-server 服务端 复制配置文件(从redis的源码目录中复制redis.conf到redis的安装目录) 1cp /path/redis.conf /home/centos/redis/anzhuang 服务端启动与客户端连接(默认redis端口号为6379，启动方式为前台启动，就是服务端启动打开一个界面，不能关闭，重新开一个客户端界面进行连接) 123cd /home/centos/redis/anzhuang/bin/./redis-server redis.conf 服务端启动./redis-cli [-h localhost -p 6379 ] 客户端连接 让redis以后台进程的形式运行 编辑conf配置文件,修改如下内容： 1daemonize yes 至此，redis已经安装完成，是不是很简单呢？？Enjoy12345ps aux|grep redis 查看redis运行进程redis-cli shutdown 关闭redis服务/etc/init.d/redis-server start 启动redis/etc/init.d/redis-server stop 关闭redis/etc/init.d/redis-server restart 重启redis 注:Make编译时易碰到的问题,时间错误.原因: 源码是官方configure过的,但官方configure时,生成的文件有时间戳信息, Make只能发生在configure之后如果你的虚拟机的时间不对,比官方configure时间早解决:12date -s ‘yyyy-mm-dd hh:mm:ss’ 重写系统时间clock -w 把当前系统时间写入CMOS中 了解系统时间与CMOS时间关系1系统时间由linux操作系统来维护，CMOS时间是CMOS芯片保存的时间。系统启动时，操作系统将从CMOS读出时间记录为系统时间，同时操作系统每隔一段时间自动将系统时间写入CMOS中，如果使用date命令修改完系统时间后立即重启电脑，操作系统还没有将系统时间写入CMOS中，这样开机后就还是修改前的时间，为了保险起见，建议手动使用命令clock将系统时间写入CMOS中。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>教程| redis教程 | redis特点及安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--策略模式]]></title>
    <url>%2F2017%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式定义1策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 图解 代码测试Duck：1234567891011121314151617181920212223public abstract class Duck &#123; //为行为接口类型声明两个引用变量，所有鸭子子类都继承它们。 public IFlyBehavior flyBehavior; //每只鸭子都引用实现QuackBehavior接口的对象。 public IQuackBehavior quackBehavior; public Duck() &#123; &#125; public abstract void Display(); public void PerformFly() &#123; //委托给行为类 flyBehavior.Fly(); &#125; public void PerformQuack() &#123; //鸭子将呱呱叫行为委托给quackBehavior引用的对象。 quackBehavior.Quack(); &#125; public void Swim() &#123; Console.WriteLine("会游泳....."); &#125; &#125; IFlyBehavior:12345public interface IFlyBehavior &#123; //所有飞行行为必须实现的接口。 void Fly(); &#125; IQuackBehavior:1234public interface IQuackBehavior &#123; void Quack(); &#125; FlyWithWings: 123456789public class FlyWithWings : IFlyBehavior &#123; #region IFlyBehavior 成员 public void Fly() &#123; Console.WriteLine("会飞......"); &#125; #endregion &#125; FlyNoWay: 123456789public class FlyNoWay : IFlyBehavior &#123; #region IFlyBehavior 成员 public void Fly() &#123; Console.WriteLine("不会飞......"); &#125; #endregion &#125; MuteQuack:123456789public class MuteQuack : IQuackBehavior &#123; #region IQuackBehavior 成员 public void Quack() &#123; Console.WriteLine("不会叫"); &#125; #endregion &#125; Quack:123456789public class Quack : IQuackBehavior &#123; #region IQuackBehavior 成员 void IQuackBehavior.Quack() &#123; Console.WriteLine("呱呱叫......"); &#125; #endregion &#125; Squeak: 123456789public class Squeak : IQuackBehavior &#123; #region IQuackBehavior 成员 public void Quack() &#123; Console.WriteLine("吱吱叫......."); &#125; #endregion &#125; MallardDuck: 1234567891011121314public class MallardDuck : Duck &#123; public MallardDuck() &#123; //FlyWithWings作为IFlyBehavior类型 base.flyBehavior = new FlyWithWings(); //Quack类处理呱呱叫。 base.quackBehavior = new Quack(); &#125; public override void Display() &#123; Console.WriteLine("绿头鸭......"); &#125; &#125; WoodDuck:123456789101112public class WoodDuck : Duck &#123; public WoodDuck() &#123; flyBehavior = new FlyNoWay(); quackBehavior = new MuteQuack(); &#125; public override void Display() &#123; Console.WriteLine("木头鸭子....."); &#125; &#125; Main:12345678910111213141516171819class Program &#123; static void Main(string[] args) &#123; Duck mallard = new MallardDuck(); mallard.Display(); //调用MallardDuck继承来的perform方法，进而将绿头鸭的行为委托给quack和fly的行为类来处理。 mallard.PerformFly(); mallard.PerformQuack(); mallard.Swim(); Duck wood = new WoodDuck(); wood.Display(); wood.PerformFly(); wood.PerformQuack(); wood.Swim(); Console.Read(); &#125; &#125; 结果 总结00基础 抽象 继承 多态 封装 00原则 封装变化 多用组合，少用继承。使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。 针对接口编程，不针对实现编程 优点 1、 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 2、 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 3、 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点 1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 2、 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。[不很清楚]]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>教程| 设计模式教程 | 设计模式--策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客后端管理工具---hexo-admin]]></title>
    <url>%2F2017%2F12%2F15%2Fhexo%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-hexo-admin%2F</url>
    <content type="text"><![CDATA[前言最近又重新折腾和整理啦一下自己的博客，发现每次写博客都会进入修改-&gt;启动hexo server-&gt;修改的回圈，这是一个非常麻烦的过程，有没有好的解决方案呢？？？困惑？肯定有呀！！也就是我接下来要介绍的hexo-admin 安装插件hexo-admin 这款插件的安装也非常简单，通过简单的npm就可以一键安装啦。进入搭建好的博客目录，执行安装指令，启动hexo的server，在本地就可以进行文章的管理与发布啦。 1234cd hexohexonpm install -save hexo-adminhexo server -dopen http://localhost:4000/admin/ 功能其实我是边写这篇博客，边了解这个插件功能的，发现很多优点： 即时保存在网页上直接写博客，不用进行额外的保存。这款插件会每隔几秒钟就会自动保存一次，再也不怕忘记保存啦。但是习惯了常常默认按ctrl+s来保存，变成了保存网页，哈哈。我们可以发现目录架构中增加了两个文件夹，hexo-admin在原来hexo的基础上加入了draft和discarded来保存我们的草稿和删除的markdown。不用怕误删，也不用怕自己没写好的草稿，不小心就发布出去啦。 即时渲染会发现如果你是在修改当前页面的markdown文件，server上也会动态发生效果，就可以发现效果已经变啦。 总结2017年已经接近尾端，一个晴朗的白天，放下作业，整理一下自己的思绪，写写总结。无意中间发现这么一款管理博客的神器，也是蛮开心的！以后自己写东西也会方便很多！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程| Hexo教程 | Hexo博客后端管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程编程核心技术----java多线程技能]]></title>
    <url>%2F2017%2F11%2F12%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[概念进程：通过查看“windows任务管理器”中的列表，完全可以将运行在内存中的exe文件理解成进程。 进程是受操作系统管理的基本运行单元。 线程：线程可以理解成是在进程中独立运行的子任务。比如，QQ.exe运行时就有很多的子任务在同时运行。 那么，使用多线程有什么优点呢？ 单线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，任务2必须等任务1执行完10秒之后才能执行。 特点：排队执行，即同步，CPU利用率大幅降低。 多线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，CPU完全可以在任务1和任务2之间来回切换，使任务2不必等待10秒再运行。 特点：在使用异步，系统的运行效率得到大幅度提升。 多线程是异步的，所以千万不要把Eclipse里代码的顺序当成线程的执行顺序，线程被调用的时机是随机的。 一个进程在运行时至少有一个线程在运行，比如在Java中，调用public static void main()方法就会创建一个线程，名字叫main（这个main和main方法名字没有任何关系），而且它是由JVM创建的。 使用多线程实现多线程编程有两种主要方式：一种是继承Thread类，另一种是实现Runnable接口。都是重写run方法。（java支持单继承） Thread.java类也实现啦Runnable接口 Thread.java类中的start()方法通知“线程规划池”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。 thread.run()方法而是同步，此线程对象并不交给“线程规划器”来进行处理，而是由main主线程来调用run()方法，也就是必须等待run()方法中的代码执行完之后才可以执行后面代码。 执行start()方法的顺序并不代表线程启动的顺序。 非线程安全：多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改，值不同步的情况，进而影响程序的执行流程。（使用synchronized关键字加锁） 留意i++与System.out.println()的异常：使用System.out.println(&quot;i=&quot;+(i++))虽然println()方法内部是同步的，但i++的操作却是在进入println()之前发生的，所以有发生非线程安全问题的概率。 currentThread()方法：返回代码段正在被哪个线程调用的信息。 isAlive()方法：判断当前线程是否处于活动状态。 sleep()方法：在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。 getId()方法：获取线程的唯一标识。 yield()方法：放弃当前的CPU资源，将它让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。 停止线程 123线程正常退出，即run()方法完成后线程终止。使用stop()方法强行终止线程。（不推荐使用）使用interrupt方法中断线程。（还需要加入一个判断才可以完成线程----抛出异常，break，return） 判断线程是否是停止状态： 123this.interrupted():测试当前线程是否已经是中断状态，执行后具有将状标志置清除为false的功能。当前线程是指运行this.interrupted()方法的线程。this.isInterrupted():测试线程Thread对象是否已经是中断状态，但不清除状态标志。 暂停线程使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。 缺点：独占，不同步 线程优先级线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。 设置线程优先级有助于帮“线程规划器”确定在下一次选择哪个线程来优先执行。 线程优先级分为1~10这10个等级，如果小于1或大于10，则JDK抛出异常throw new IllegalArgumentException(), JDK使用3个常量来预置定义优先级的值： 123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程优先级具有继承性：A线程启动B线程，则B线程的优先级与A一样。 高优先级的线程总是大部分先执行完，但不代表高优先线程全部先执行完。 线程的优先级与代码的执行顺序无关。 守护线程 在java线程中有两种线程，一种是用户线程，另一种是守护线程。 任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，当进程中不存在非守护线程了，则守护线程自动销毁。 典型的守护线程是：GC（垃圾回收器） thread.setDaemon(true)：设置当前线程为守护线程。]]></content>
      <categories>
        <category>java多线程编程核心技术| java多线程技能</category>
      </categories>
      <tags>
        <tag>java多线程编程核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客源文件备份]]></title>
    <url>%2F2017%2F11%2F11%2FHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[前言使用Hexo编写博客还是比较Nice的，但是有一个问题就是Hexo博客的源文件是放在本地的，如果换一台电脑更新博客或者源文件不小心丢失啦，那就麻烦啦。未雨绸缪，现在给出这一问题的解决方案。 备份方案想到的办法： 将博客源文件拷贝到U盘里—但是这样做，无法同步。 使用网盘的话，据说.git文件不能上传同步—而且我对国内的网盘也不放心。 综合起来，我觉得比较流行的方法就是： 将博客源文件托管到Github. 实现方法： 在Github上创建一个新的repository ,名字为hexohexo。（与你的本地博客源文件文件名相同即可） 进入本地hexohexo文件夹,执行以下命令： 1git init 设置远程仓库地址，并更新，本地文件夹与远程仓库绑定： 12git remote add origin git@github.com:hanweizhe/hexohexo.gitgit pull orgin master (非必须项) 修改.gitignore文件（如果没有就手动创建一个），在里面加入.*.log和public/以及.deploy*/。因为每次执行hexo generate命令时，上述目录都会被重写更新，因此忽略上述目录下的文件更新，加快push速度。 完成Hexo源码在本地的提交，执行以下命令： 12git add .git commit -m "添加Hexo源码文件作为备份" 将本地仓库文件推送到Github，执行以下命令： 1git push origin master 当远程仓库有更新时，执行以下命令，即可同步远程源代码文件到本地文件。 1git pull origin master 现在在任何一台电脑上，只需要git clone git@github.com:hanweizhe/hexoohexo.git 即可将Hexo源文件复制到本地。（请将git clone git@github.com:hanweizhe/hexohexo.git 换成自己远程仓库地址） 在本地编写完博客时，顺序执行以下命令，即可完成Hexo博客源文件的同步更新，保持Github上的Hexo源码为最新的版本。 123git add .git commit -m "更新Hexo源文件"git push origin master 至此，Hexo源代码文件就完成了同步与更新。 对于博主这种懒人，每次更新博文都需要输入两三行重复的git命令真是一件麻烦事，说不定哪天就忘记push到Github上啦。有没有更省事的办法？？完成自动备份 ？？ 原理利用NodeJs的事件监听机制实现监听Hexo的deployAfter事件，待博客部署完成之后自动运行Git备份命令，以达到自动备份的目的。 实现将hexohexo目录加入Git仓库（见前面）。安装shelljs模块。要实现这个自动备份功能，需要依赖NodeJs的一个shelljs模块，该模块重新包装啦child_process ,调用系统命令更加方便。该模块需要安装后使用。 键入以下命令，完成shelljs模块的安装： 1npm install --save shelljs 编写自动备份脚本待到模块安装完成，在hexohexo根目录的scripts文件夹下新建一个js文件，文件名字随意取。 如果没有scripts目录，请新建一个。 然后再脚本中，写入以下内容： 123456789101112131415161718192021222324252627282930require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当 deploy完成后执行备份 run(); &#125;); &#125; catch (e) &#123; console.log("产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：" + e.toString()); &#125; function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo("======================Auto Backup Begin==========================="); cd('D:/hexohexo'); //此处修改为 Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am "Form auto backup script\'s commit"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo("==================Auto Backup Complete============================") &#125; &#125; 其中，需要修改地15行的D:/hexohexo路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径）； 如果你的Git远程仓库名称不为origin的话（默认为origin），还需要修改第24行执行的push命令，修改成自己的远程仓库名与相应的分支名。 保存脚本并退出，然后执行hexo deploy命令，将会得到类似以下结果： 1234567891011121314151617181920212223INFO Deploying: git&gt;INFO Clearing .deploy folder...INFO Copying files from public folder...[master 3020788] Site updated: 2015-07-06 15:08:06 5 files changed, 160 insertions(+), 58 deletions(-)Branch master set up to track remote branch gh-pages from git@github.com:smilexiamo/notes.git.To git@github.com:smilexiamo/notes.git 02adbe4..3020788 master -&gt; gh-pagesOn branch masternothing to commit, working directory cleanBranch master set up to track remote branch gitcafe-pages from git@gitcafe.com:smilexiamo/smilexiamo.git.To git@gitcafe.com:smilexiamo/smilexiamo.git 02adbe4..3020788 master -&gt; gitcafe-pagesINFO Deploy done: git======================Auto Backup Begin===========================[master f044360] Form auto backup script's commit 2 files changed, 35 insertions(+), 2 deletions(-) rewrite db.json (100%)To git@github.com:smilexiamo/hexo.git 8f2b4b4..f044360 master -&gt; master==================Auto Backup Complete============================ 这样子，每次更新博客并hexo deploy到服务器上之后。备份就会自动启动并完成备份啦！~~~ 是不是很方便呀！ Enjoy it!]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程| Hexo教程 | Hexo源文件备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo极速搭建博客]]></title>
    <url>%2F2017%2F11%2F10%2F%E7%94%A8hexo%E6%9E%81%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo是一个非常轻量且快速的博客生成框架，可以使用markdown便捷的生成文章。 本文主要介绍windows下如何搭建hexo5.1.3+环境并发布至github。默认读者具有命令行使用经验和一定的web编程基础。 hexo搭建完成后只需要三步就可以完成博文的更新。 123hexo n # 新建hexo g # 生成hexo d # 发布 下面介绍windows下如何搭建hexo5.1.3环境并发布至github 环境准备安装node.js到node.js官网下载node.js并安装。我使用的是win8.1x64下的8.9.1版。 安装Gitgit客户端很多，我使用的是git官方提供的工具，下载速度可能较慢。 安装sublime（非必须）作为一个小前端，sublime作为编辑器实在是不能再好用，不过这个只是文本编辑器使用，大家可以根据喜好自由选择工具，切记不要使用windows自带的记事本。 Github我们使用Github官方提供的Github Pages这一服务作为静态博客的服务器。申请Github账户和与git通过ssh建立连接网上很多详细的教程，此处不再赘述。 GitHub Help - Generating SSH Keys hexo安装node.js和git安装好后，建议使用git提供的命令行窗口进行操作。 windows自带的cmd会报错。 执行如下命令可安装hexo： 1npm install -g hexo hexo初始化执行init命令初始化hexo到你指定的目录。 1hexo init &lt;folder&gt; #folder为你指定的目录 或者cd到你的指定目录，执行 hexo init 至此，hexo的安装工作已经完成。 hexo必备插件12345678$ npm install hexo-generator-index --save #索引生成器$ npm install hexo-generator-archive --save #归档生成器$ npm install hexo-generator-category --save #分类生成器$ npm install hexo-generator-tag --save #标签生成器$ npm install hexo-server --save #本地服务$ npm install hexo-deploy-git --save #hexo通过git发布（必装）$ npm install hexo-render-market@0.2.7 --save #渲染器$ npm install hexo-render-stylus@0.3.0 --save #渲染器 生成静态页面cd至之前初始化的目录，执行如下命令，即可生成静态页面至public目录 1$ hexo g 本地启动执行如下命令，启动本地服务器，进行预览。必须安装hexo-server插件，不然无法启动本地服务器。 1$ hexo s 浏览器输入localhost：4000即可访问默认的hexo博客效果。 注意： hosts文件中localhost是否被占用以及4000端口可能被福昕阅读器占用。 发布编辑hexo根目录下的_config.yml文件，找到最下面的deploy，我使用的是hexo5.1.3为如下格式。 1234deploy: type: git repo: https://github.com/hanweizhe/hanweizhe.hithub.io.git #你的Github Pages的https链接 branch: master 保存配置文件后，执行如下命令： 1$ hexo d 注意： yml格式文件冒号后面必须加一个空格。 执行完毕后访问hanweizhe.github.io即可看到部署在Github上的默认博客，第一次发布可能会有10分钟的延迟。 至此，hexo已经成功帮助我们生成了一个博客，非常的方便。 附录常用命令：1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" #新建页面$ hexo generate #根据source目录md文件生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，'ctrl+c'关闭server）$ hexo deploy #将.deploy目录部署到Github$ hexo help #查看帮助$ hexo vwesion #查看Hexo的版本 简写：1234hexo g == hexo generatehexo s == hexo serverhexo d == hexo deployhexo n == hexo new 坑： 有时会出现首页只有一篇文章的情况，这个时候需要hexo渲染两次，原因不明。 标题中不能含有[]，否则无法编译。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程| Hexo教程 | Hexo快速搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
