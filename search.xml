<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo博客后端管里工具---hexo-admin]]></title>
    <url>%2F2017%2F12%2F15%2Fhexo%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF%E7%AE%A1%E9%87%8C%E5%B7%A5%E5%85%B7-hexo-admin%2F</url>
    <content type="text"><![CDATA[前言最近又重新折腾和整理啦一下自己的博客，发现每次写博客都会进入修改-&gt;启动hexo server-&gt;修改的回圈，进入一个非常麻烦的过程，有没有好的解决方案呢？？？困惑？肯定有呀！！也就是我接下来要介绍的hexo-admin 安装插件hexo-admin 这款插件的安装也非常简单，通过简单的npm就可以一键安装啦。进入搭建好的博客目录，执行安装指令，启动hexo的server，在本地就可以进行文章的管理与发布啦。 1234cd hexohexonpm install -save hexo-adminhexo server -dopen http://localhost:4000/admin/ 功能其实我是边写这篇博客，边了解这个插件功能的，发现很多优点： 即时保存在网页上直接写博客，不用进行额外的保存。这款插件会每隔几秒钟就会自动保存一次，再也不怕忘记保存啦。但是习惯了常常默认按ctrl+s来保存，变成了保存网页，哈哈。我们可以发现目录架构中增加了两个文件夹，hexo-admin在原来hexo的基础上加入了draft和discarded来保存我们的草稿和删除的markdown。不用怕误删，也不用怕自己没写好的草稿，不小心就发布出去啦。 即时渲染会发现如果你是在修改当前页面的markdown文件，server上也会动态发生效果，就可以发现效果已经变啦。 总结2017年已经接近尾端，一个晴朗的白天，放下作业，整理一下自己的思绪，写写总结。无意中间发现这么一款管理博客的神器，也是蛮开心的！以后自己写东西也会方便很多！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程| Hexo教程 | Hexo博客后端管里工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程编程核心技术----java多线程技能]]></title>
    <url>%2F2017%2F11%2F12%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[概念进程：通过查看“windows任务管理器”中的列表，完全可以将运行在内存中的exe文件理解成进程。 进程是受操作系统管理的基本运行单元。 线程：线程可以理解成是在进程中独立运行的子任务。比如，QQ.exe运行时就有很多的子任务在同时运行。 那么，使用多线程有什么优点呢？ 单线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，任务2必须等任务1执行完10秒之后才能执行。 特点：排队执行，即同步，CPU利用率大幅降低。 多线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，CPU完全可以在任务1和任务2之间来回切换，使任务2不必等待10秒再运行。 特点：在使用异步，系统的运行效率得到大幅度提升。 多线程是异步的，所以千万不要把Eclipse里代码的顺序当成线程的执行顺序，线程被调用的时机是随机的。 一个进程在运行时至少有一个线程在运行，比如在Java中，调用public static void main()方法就会创建一个线程，名字叫main（这个main和main方法名字没有任何关系），而且它是由JVM创建的。 使用多线程实现多线程编程有两种主要方式：一种是继承Thread类，另一种是实现Runnable接口。都是重写run方法。（java支持单继承） Thread.java类也实现啦Runnable接口 Thread.java类中的start()方法通知“线程规划池”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。 thread.run()方法而是同步，此线程对象并不交给“线程规划器”来进行处理，而是由main主线程来调用run()方法，也就是必须等待run()方法中的代码执行完之后才可以执行后面代码。 执行start()方法的顺序并不代表线程启动的顺序。 非线程安全：多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改，值不同步的情况，进而影响程序的执行流程。（使用synchronized关键字加锁） 留意i++与System.out.println()的异常：使用System.out.println(&quot;i=&quot;+(i++))虽然println()方法内部是同步的，但i++的操作却是在进入println()之前发生的，所以有发生非线程安全问题的概率。 currentThread()方法：返回代码段正在被哪个线程调用的信息。 isAlive()方法：判断当前线程是否处于活动状态。 sleep()方法：在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。 getId()方法：获取线程的唯一标识。 yield()方法：放弃当前的CPU资源，将它让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。 停止线程 123线程正常退出，即run()方法完成后线程终止。使用stop()方法强行终止线程。（不推荐使用）使用interrupt方法中断线程。（还需要加入一个判断才可以完成线程----抛出异常，break，return） 判断线程是否是停止状态： 123this.interrupted():测试当前线程是否已经是中断状态，执行后具有将状标志置清除为false的功能。当前线程是指运行this.interrupted()方法的线程。this.isInterrupted():测试线程Thread对象是否已经是中断状态，但不清除状态标志。 暂停线程使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。 缺点：独占，不同步 线程优先级线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。 设置线程优先级有助于帮“线程规划器”确定在下一次选择哪个线程来优先执行。 线程优先级分为1~10这10个等级，如果小于1或大于10，则JDK抛出异常throw new IllegalArgumentException(), JDK使用3个常量来预置定义优先级的值： 123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程优先级具有继承性：A线程启动B线程，则B线程的优先级与A一样。 高优先级的线程总是大部分先执行完，但不代表高优先线程全部先执行完。 线程的优先级与代码的执行顺序无关。 守护线程 在java线程中有两种线程，一种是用户线程，另一种是守护线程。 任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，当进程中不存在非守护线程了，则守护线程自动销毁。 典型的守护线程是：GC（垃圾回收器） thread.setDaemon(true)：设置当前线程为守护线程。]]></content>
      <categories>
        <category>java多线程编程核心技术| java多线程技能</category>
      </categories>
      <tags>
        <tag>java多线程编程核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客源文件备份]]></title>
    <url>%2F2017%2F11%2F11%2FHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[前言使用Hexo编写博客还是比较Nice的，但是有一个问题就是Hexo博客的源文件是放在本地的，如果换一台电脑更新博客或者源文件不小心丢失啦，那就麻烦啦。未雨绸缪，现在给出这一问题的解决方案。 备份方案想到的办法： 将博客源文件拷贝到U盘里—但是这样做，无法同步。 使用网盘的话，据说.git文件不能上传同步—而且我对国内的网盘也不放心。 综合起来，我觉得比较流行的方法就是： 将博客源文件托管到Github. 实现方法： 在Github上创建一个新的repository ,名字为hexohexo。（与你的本地博客源文件文件名相同即可） 进入本地hexohexo文件夹,执行以下命令： 1git init 设置远程仓库地址，并更新，本地文件夹与远程仓库绑定： 12git remote add origin git@github.com:hanweizhe/hexohexo.gitgit pull orgin master (非必须项) 修改.gitignore文件（如果没有就手动创建一个），在里面加入.*.log和public/以及.deploy*/。因为每次执行hexo generate命令时，上述目录都会被重写更新，因此忽略上述目录下的文件更新，加快push速度。 完成Hexo源码在本地的提交，执行以下命令： 12git add .git commit -m "添加Hexo源码文件作为备份" 将本地仓库文件推送到Github，执行以下命令： 1git push origin master 当远程仓库有更新时，执行以下命令，即可同步远程源代码文件到本地文件。 1git pull origin master 现在在任何一台电脑上，只需要git clone git@github.com:hanweizhe/hexoohexo.git 即可将Hexo源文件复制到本地。（请将git clone git@github.com:hanweizhe/hexohexo.git 换成自己远程仓库地址） 在本地编写完博客时，顺序执行以下命令，即可完成Hexo博客源文件的同步更新，保持Github上的Hexo源码为最新的版本。 123git add .git commit -m "更新Hexo源文件"git push origin master 至此，Hexo源代码文件就完成了同步与更新。 对于博主这种懒人，每次更新博文都需要输入两三行重复的git命令真是一件麻烦事，说不定哪天就忘记push到Github上啦。有没有更省事的办法？？完成自动备份 ？？ 原理利用NodeJs的事件监听机制实现监听Hexo的deployAfter事件，待博客部署完成之后自动运行Git备份命令，以达到自动备份的目的。 实现将hexohexo目录加入Git仓库（见前面）。安装shelljs模块。要实现这个自动备份功能，需要依赖NodeJs的一个shelljs模块，该模块重新包装啦child_process ,调用系统命令更加方便。该模块需要安装后使用。 键入以下命令，完成shelljs模块的安装： 1npm install --save shelljs 编写自动备份脚本待到模块安装完成，在hexohexo根目录的scripts文件夹下新建一个js文件，文件名字随意取。 如果没有scripts目录，请新建一个。 然后再脚本中，写入以下内容： 123456789101112131415161718192021222324252627282930require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当 deploy完成后执行备份 run(); &#125;); &#125; catch (e) &#123; console.log("产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：" + e.toString()); &#125; function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo("======================Auto Backup Begin==========================="); cd('D:/hexohexo'); //此处修改为 Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am "Form auto backup script\'s commit"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo("==================Auto Backup Complete============================") &#125; &#125; 其中，需要修改地17行的D:/hexohexo路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径）； 如果你的Git远程仓库名称不为origin的话（默认为origin），还需要修改第28行执行的push命令，修改成自己的远程仓库名与相应的分支名。 保存脚本并退出，然后执行hexo deploy命令，将会得到类似以下结果： 1234567891011121314151617181920212223 INFO Deploying: git&gt;INFO Clearing .deploy folder...INFO Copying files from public folder...[master 3020788] Site updated: 2015-07-06 15:08:06 5 files changed, 160 insertions(+), 58 deletions(-)Branch master set up to track remote branch gh-pages from git@github.com:smilexiamo/notes.git.To git@github.com:smilexiamo/notes.git 02adbe4..3020788 master -&gt; gh-pagesOn branch masternothing to commit, working directory cleanBranch master set up to track remote branch gitcafe-pages from git@gitcafe.com:smilexiamo/smilexiamo.git.To git@gitcafe.com:smilexiamo/smilexiamo.git 02adbe4..3020788 master -&gt; gitcafe-pagesINFO Deploy done: git======================Auto Backup Begin===========================[master f044360] Form auto backup script's commit 2 files changed, 35 insertions(+), 2 deletions(-) rewrite db.json (100%)To git@github.com:smilexiamo/hexo.git 8f2b4b4..f044360 master -&gt; master==================Auto Backup Complete============================ 这样子，每次更新博客并hexo deploy到服务器上之后。备份就会自动启动并完成备份啦！~~~ 是不是很方便呀！ Enjoy it!]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程| Hexo教程 | Hexo源文件备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo极速搭建博客]]></title>
    <url>%2F2017%2F11%2F10%2F%E7%94%A8hexo%E6%9E%81%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo是一个非常轻量且快速的博客生成框架，可以使用markdown便捷的生成文章。 本文主要介绍windows下如何搭建hexo5.1.3+环境并发布至github。默认读者具有命令行使用经验和一定的web编程基础。 hexo搭建完成后只需要三步就可以完成博文的更新。 123hexo n # 新建hexo g # 生成hexo d # 发布 下面介绍windows下如何搭建hexo5.1.3环境并发布至github 环境准备安装node.js到node.js官网下载node.js并安装。我使用的是win8.1x64下的8.9.1版。 安装Gitgit客户端很多，我使用的是git官方提供的工具，下载速度可能较慢。 安装sublime（非必须）作为一个小前端，sublime作为编辑器实在是不能再好用，不过这个只是文本编辑器使用，大家可以根据喜好自由选择工具，切记不要使用windows自带的记事本。 Github我们使用Github官方提供的Github Pages这一服务作为静态博客的服务器。申请Github账户和与git通过ssh建立连接网上很多详细的教程，此处不再赘述。 GitHub Help - Generating SSH Keys hexo安装node.js和git安装好后，建议使用git提供的命令行窗口进行操作。 windows自带的cmd会报错。 执行如下命令可安装hexo： 1npm install -g hexo hexo初始化执行init命令初始化hexo到你指定的目录。 1hexo init &lt;folder&gt; #folder为你指定的目录 或者cd到你的指定目录，执行 hexo init 至此，hexo的安装工作已经完成。 hexo必备插件12345678$ npm install hexo-generator-index --save #索引生成器$ npm install hexo-generator-archive --save #归档生成器$ npm install hexo-generator-category --save #分类生成器$ npm install hexo-generator-tag --save #标签生成器$ npm install hexo-server --save #本地服务$ npm install hexo-deploy-git --save #hexo通过git发布（必装）$ npm install hexo-render-market@0.2.7 --save #渲染器$ npm install hexo-render-stylus@0.3.0 --save #渲染器 生成静态页面cd至之前初始化的目录，执行如下命令，即可生成静态页面至public目录 1$ hexo g 本地启动执行如下命令，启动本地服务器，进行预览。必须安装hexo-server插件，不然无法启动本地服务器。 1$ hexo s 浏览器输入localhost：4000即可访问默认的hexo博客效果。 注意： hosts文件中localhost是否被占用以及4000端口可能被福昕阅读器占用。 发布编辑hexo根目录下的_config.yml文件，找到最下面的deploy，我使用的是hexo5.1.3为如下格式。 1234deploy: type: git repo: https://github.com/hanweizhe/hanweizhe.hithub.io.git #你的Github Pages的https链接 branch: master 保存配置文件后，执行如下命令： 1$ hexo d 注意： yml格式文件冒号后面必须加一个空格。 执行完毕后访问hanweizhe.github.io即可看到部署在Github上的默认博客，第一次发布可能会有10分钟的延迟。 至此，hexo已经成功帮助我们生成了一个博客，非常的方便。 附录常用命令：1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" #新建页面$ hexo generate #根据source目录md文件生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，'ctrl+c'关闭server）$ hexo deploy #将.deploy目录部署到Github$ hexo help #查看帮助$ hexo vwesion #查看Hexo的版本 简写：1234hexo g == hexo generatehexo s == hexo serverhexo d == hexo deployhexo n == hexo new 坑： 有时会出现首页只有一篇文章的情况，这个时候需要hexo渲染两次，原因不明。 标题中不能含有[]，否则无法编译。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程| Hexo教程 | Hexo快速搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
