<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的第一个博客</title>
  
  <subtitle>xia1769655343@hotmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-05T06:25:36.277Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>夏茂盛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis的特点及安装(第一部分)</title>
    <link href="http://yoursite.com/2018/02/05/redis%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E5%AE%89%E8%A3%85(%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/05/redis的特点及安装(第一部分)/</id>
    <published>2018-02-05T02:45:54.000Z</published>
    <updated>2018-02-05T06:25:36.277Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>2017年已经接近尾声，最近自己在慧与实习(原惠普)也没啥事，闲暇之余，想起自己已经好久没有写博客，决定把redis的博客稍微写一写，相当于做一份笔记，以后方便查阅。</p><h4 id="redis是啥呢"><a href="#redis是啥呢" class="headerlink" title="redis是啥呢"></a>redis是啥呢</h4><p><a href="https://redis.io/" target="_blank" rel="external">redis的官方站点</a></p><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries.</p><p>redis是开源(BSD许可),内存数据结构存储.可以当作数据库，缓存和信息代理使用。它支持的数据结构服务，有字符串、哈希表、列表、集合、有序集合范围查询，位图，hyperloglogs和半径查询地理信息的索引。</p><h4 id="redis和memcached的简单比较"><a href="#redis和memcached的简单比较" class="headerlink" title="redis和memcached的简单比较"></a>redis和memcached的简单比较</h4><p>redis和memcached相比,独特之处:</p><ol><li><p>redis可以用来做存储(storge)和缓存(cache), 而memcached只可以用来做缓存(cache)。这个特点主要因为其有”持久化”的功能.<br><strong>持久化简单一句话就是内存里面数据可以同步到光盘或硬盘等长久可以存储的设备上面。</strong></p></li><li><p>存储的数据有”结构”,对于memcached来说,存储的数据,只有1种类型–”字符串”,而redis则可以存储字符串,链表,哈希结构,集合,有序集合.</p></li></ol><h4 id="redis下载安装"><a href="#redis下载安装" class="headerlink" title="redis下载安装"></a>redis下载安装</h4><ol><li>官方站点: <strong>redis.io</strong> 下载最新版或者最新stable版</li><li>解压源码并进入目录</li><li>不用configure(生成makefile)</li><li>直接make 编译(如果是32位机器 make 32bit;时间问题见末尾)</li><li>可选步骤: make test  测试编译情况<br>(可能出现: need tcl  &gt;8.4这种情况, yum install tcl)</li><li><p>make install安装到指定的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-4.0.8.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.8.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-4.0.8</span><br><span class="line">$ make</span><br><span class="line">$ make  PREFIX=/home/centos/redis/anzhuang install 注: PREFIX要大写</span><br></pre></td></tr></table></figure></li><li><p>make install之后,得到如下几个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark  性能测试工具</span><br><span class="line">redis-check-aof  日志文件检测工具(比如断电造成日志损坏,可以检测并修复)</span><br><span class="line">redis-check-dump  快照文件检测工具,效果类上</span><br><span class="line">redis-cli  客户端</span><br><span class="line">redis-server 服务端</span><br></pre></td></tr></table></figure></li><li><p>复制配置文件(从redis的源码目录中复制redis.conf到redis的安装目录)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /path/redis.conf /home/centos/redis/anzhuang</span><br></pre></td></tr></table></figure></li><li><p>服务端启动与客户端连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /home/centos/redis/anzhuang/bin/</span><br><span class="line">./redis-server redis.conf  服务端启动</span><br><span class="line">./redis-cli [-h localhost -p 6379 ] 客户端连接</span><br><span class="line">~~~  </span><br><span class="line">默认redis端口号为6379，启动方式为前台启动，就是服务端启动打开一个界面，不能关闭，重新开一个客户端界面进行连接。</span><br><span class="line"></span><br><span class="line">10. 让redis以后台进程的形式运行</span><br><span class="line"></span><br><span class="line"> 编辑conf配置文件,修改如下内容：</span><br><span class="line">~~~ bash</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure></li></ol><p>至此，redis已经安装完成，是不是很简单呢？？Enjoy<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep redis  查看redis运行进程</span><br><span class="line">redis-cli shutdown  关闭redis服务</span><br><span class="line">/etc/init.d/redis-server start  启动redis</span><br><span class="line">/etc/init.d/redis-server stop  关闭redis</span><br><span class="line">/etc/init.d/redis-server restart  重启redis</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>:Make编译时易碰到的问题,时间错误.<br>原因: 源码是官方configure过的,但官方configure时,生成的文件有时间戳信息,<strong> Make只能发生在configure之后</strong><br>如果你的虚拟机的时间不对,比官方configure时间早<br>解决:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -s ‘yyyy-mm-dd hh:mm:ss’ 重写系统时间</span><br><span class="line">clock -w  把当前系统时间写入CMOS中</span><br></pre></td></tr></table></figure></p><h4 id="了解系统时间与CMOS时间关系"><a href="#了解系统时间与CMOS时间关系" class="headerlink" title="了解系统时间与CMOS时间关系"></a>了解系统时间与CMOS时间关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统时间由linux操作系统来维护，CMOS时间是CMOS芯片保存的时间。系统启动时，操作系统将从CMOS读出时间记录为系统时间，同时操作系统每隔一段时间自动将系统时间写入CMOS中，如果使用date命令修改完系统时间后立即重启电脑，操作系统还没有将系统时间写入CMOS中，这样开机后就还是修改前的时间，为了保险起见，建议手动使用命令clock将系统时间写入CMOS中。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;2017年已经接近尾声，最近自己在慧与实习(原惠普)也没啥事，闲暇之余，想起自己已经好久没有写博客，决定把redis的博客稍微写一写，相当于
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis特点及安装" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E7%89%B9%E7%82%B9%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--策略模式</title>
    <link href="http://yoursite.com/2017/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/15/设计模式-策略模式/</id>
    <published>2017-12-15T06:28:54.000Z</published>
    <updated>2017-12-15T08:09:16.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</span><br></pre></td></tr></table></figure><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/image/策略模式.png" alt="策略模式"></p><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><p>Duck：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Duck</span><br><span class="line">    &#123;</span><br><span class="line">        //为行为接口类型声明两个引用变量，所有鸭子子类都继承它们。</span><br><span class="line">        public IFlyBehavior flyBehavior;</span><br><span class="line">        //每只鸭子都引用实现QuackBehavior接口的对象。</span><br><span class="line">        public IQuackBehavior quackBehavior;</span><br><span class="line">        public <span class="function"><span class="title">Duck</span></span>() &#123; &#125;</span><br><span class="line">        public abstract void Display();</span><br><span class="line">        public void PerformFly()</span><br><span class="line">        &#123;</span><br><span class="line">            //委托给行为类</span><br><span class="line">            flyBehavior.Fly();</span><br><span class="line">        &#125;</span><br><span class="line">        public void PerformQuack()</span><br><span class="line">        &#123;</span><br><span class="line">            //鸭子将呱呱叫行为委托给quackBehavior引用的对象。</span><br><span class="line">            quackBehavior.Quack();</span><br><span class="line">        &#125;</span><br><span class="line">        public void Swim()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"会游泳....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>IFlyBehavior:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       //所有飞行行为必须实现的接口。</span><br><span class="line">       void Fly();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>IQuackBehavior:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       void Quack();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>FlyWithWings:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FlyWithWings : IFlyBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IFlyBehavior 成员</span></span><br><span class="line">       public void Fly()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"会飞......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>FlyNoWay:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FlyNoWay : IFlyBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IFlyBehavior 成员</span></span><br><span class="line">       public void Fly()</span><br><span class="line">       &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"不会飞......"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>MuteQuack:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MuteQuack : IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IQuackBehavior 成员</span></span><br><span class="line">       public void Quack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"不会叫"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Quack:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Quack : IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IQuackBehavior 成员</span></span><br><span class="line">       void IQuackBehavior.Quack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"呱呱叫......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Squeak:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Squeak : IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IQuackBehavior 成员</span></span><br><span class="line">       public void Quack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"吱吱叫......."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>MallardDuck:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MallardDuck : Duck</span><br><span class="line">   &#123;</span><br><span class="line">       public MallardDuck()</span><br><span class="line">        &#123;</span><br><span class="line">            //FlyWithWings作为IFlyBehavior类型</span><br><span class="line">            base.flyBehavior = new FlyWithWings();</span><br><span class="line">            //Quack类处理呱呱叫。</span><br><span class="line">            base.quackBehavior = new Quack();</span><br><span class="line">        &#125;</span><br><span class="line">       public override void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"绿头鸭......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>WoodDuck:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WoodDuck : Duck</span><br><span class="line">   &#123;</span><br><span class="line">       public WoodDuck()</span><br><span class="line">        &#123;</span><br><span class="line">            flyBehavior = new FlyNoWay();</span><br><span class="line">            quackBehavior = new MuteQuack();</span><br><span class="line">        &#125;</span><br><span class="line">       public override void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"木头鸭子....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Main:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">   &#123;</span><br><span class="line">       static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           Duck mallard = new MallardDuck();</span><br><span class="line">           mallard.Display();</span><br><span class="line">           //调用MallardDuck继承来的perform方法，进而将绿头鸭的行为委托给quack和fly的行为类来处理。</span><br><span class="line">           mallard.PerformFly();</span><br><span class="line">           mallard.PerformQuack();</span><br><span class="line">           mallard.Swim();</span><br><span class="line">           Duck wood = new WoodDuck();</span><br><span class="line">           wood.Display();</span><br><span class="line">           wood.PerformFly();</span><br><span class="line">           wood.PerformQuack();</span><br><span class="line">           wood.Swim();</span><br><span class="line">           Console.Read();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/image/运行结果1.png" alt="策略模式运行结果"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>00基础</strong></p><ul><li>抽象</li><li>继承</li><li>多态</li><li>封装</li></ul><p><strong>00原则</strong></p><ul><li>封装变化</li><li>多用组合，少用继承。<br>使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。</li><li>针对接口编程，不针对实现编程</li></ul><p><strong>优点</strong></p><p>1、 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。</p><p>2、 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。</p><p>3、 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。</p><p><strong>缺点</strong></p><p>1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</p><p>2、 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。[不很清楚]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h3&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="教程| 设计模式教程 | 设计模式--策略模式" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客后端管理工具---hexo-admin</title>
    <link href="http://yoursite.com/2017/12/15/hexo%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-hexo-admin/"/>
    <id>http://yoursite.com/2017/12/15/hexo博客后端管理工具-hexo-admin/</id>
    <published>2017-12-15T03:15:00.000Z</published>
    <updated>2017-12-15T05:49:27.402Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近又重新折腾和整理啦一下自己的博客，发现每次写博客都会进入<code>修改-&gt;启动hexo server-&gt;修改</code>的回圈，这是一个非常麻烦的过程，有没有好的解决方案呢？？？困惑？肯定有呀！！也就是我接下来要介绍的<a href="https://jaredforsyth.com/hexo-admin/" target="_blank" rel="external">hexo-admin</a></p><p><img src="/image/hexo.jpg" alt="“hexo-admin”"> </p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>hexo-admin 这款插件的安装也非常简单，通过简单的npm就可以一键安装啦。进入搭建好的博客目录，执行安装指令，启动hexo的server，在本地就可以进行文章的管理与发布啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexohexo</span><br><span class="line">npm install -save hexo-admin</span><br><span class="line">hexo server -d</span><br><span class="line">open http://localhost:4000/admin/</span><br></pre></td></tr></table></figure><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>其实我是边写这篇博客，边了解这个插件功能的，发现很多优点：</p><ul><li><p><strong>即时保存</strong><br>在网页上直接写博客，不用进行额外的保存。这款插件会每隔几秒钟就会自动保存一次，再也不怕忘记保存啦。但是习惯了常常默认按ctrl+s来保存，变成了保存网页，哈哈。<br>我们可以发现目录架构中增加了两个文件夹，hexo-admin在原来hexo的基础上加入了draft和discarded来保存我们的草稿和删除的markdown。不用怕误删，也不用怕自己没写好的草稿，不小心就发布出去啦。</p></li><li><p><strong>即时渲染</strong><br>会发现如果你是在修改当前页面的markdown文件，server上也会动态发生效果，就可以发现效果已经变啦。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>2017年已经接近尾端，一个晴朗的白天，放下作业，整理一下自己的思绪，写写总结。无意中间发现这么一款管理博客的神器，也是蛮开心的！以后自己写东西也会方便很多！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"><br></iframe>  ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近又重新折腾和整理啦一下自己的博客，发现每次写博客都会进入&lt;code&gt;修改-&amp;gt;启动hexo server-&amp;gt;修改&lt;/code&gt;
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="教程| Hexo教程 | Hexo博客后端管理工具" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-Hexo%E6%95%99%E7%A8%8B-Hexo%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程核心技术----java多线程技能</title>
    <link href="http://yoursite.com/2017/11/12/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E8%83%BD/"/>
    <id>http://yoursite.com/2017/11/12/java多线程编程核心技术-java多线程技能/</id>
    <published>2017-11-12T05:28:31.000Z</published>
    <updated>2017-11-12T07:44:39.007Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>进程</strong>：通过查看“windows任务管理器”中的列表，完全可以将运行在内存中的exe文件理解成进程。</p><p>进程是受操作系统管理的基本运行单元。</p><p><strong>线程</strong>：线程可以理解成是在进程中独立运行的子任务。比如，QQ.exe运行时就有很多的子任务在同时运行。</p><p>那么，使用多线程有什么优点呢？</p><p>单线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，任务2必须等任务1执行完10秒之后才能执行。</p><p> 特点：排队执行，即同步，CPU利用率大幅降低。</p><p>多线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，CPU完全可以在任务1和任务2之间来回切换，使任务2不必等待10秒再运行。</p><p> 特点：在使用异步，系统的运行效率得到大幅度提升。</p><p>多线程是异步的，所以千万不要把Eclipse里代码的顺序当成线程的执行顺序，线程被调用的时机是随机的。</p><p>一个进程在运行时至少有一个线程在运行，比如在Java中，调用<code>public static void main()</code>方法就会创建一个线程，名字叫main（这个main和main方法名字没有任何关系），而且它是由JVM创建的。</p><h4 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h4><p>实现多线程编程有两种主要方式：一种是继承Thread类，另一种是实现Runnable接口。都是重写<code>run</code>方法。（java支持单继承）</p><p> Thread.java类也实现啦Runnable接口</p><p>Thread.java类中的start()方法通知“线程规划池”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。</p><p>thread.run()方法而是同步，此线程对象并不交给“线程规划器”来进行处理，而是由main主线程来调用run()方法，也就是必须等待run()方法中的代码执行完之后才可以执行后面代码。</p><p>执行start()方法的顺序并不代表线程启动的顺序。</p><p>非线程安全：多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改，值不同步的情况，进而影响程序的执行流程。（使用synchronized关键字加锁）</p><p>留意i++与System.out.println()的异常：使用<code>System.out.println(&quot;i=&quot;+(i++))</code><br>虽然println()方法内部是同步的，但i++的操作却是在进入println()之前发生的，所以有发生非线程安全问题的概率。</p><p>currentThread()方法：返回代码段正在被哪个线程调用的信息。</p><p>isAlive()方法：判断当前线程是否处于活动状态。</p><p>sleep()方法：在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指<code>this.currentThread()</code>返回的线程。</p><p>getId()方法：获取线程的唯一标识。</p><p>yield()方法：放弃当前的CPU资源，将它让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。</p><h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程正常退出，即run()方法完成后线程终止。</span><br><span class="line">使用stop()方法强行终止线程。（不推荐使用）</span><br><span class="line">使用interrupt方法中断线程。（还需要加入一个判断才可以完成线程----抛出异常，break，return）</span><br></pre></td></tr></table></figure><p>判断线程是否是停止状态：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.interrupted():测试当前线程是否已经是中断状态，执行后具有将状标志置清除为false的功能。当前线程是指运行this.interrupted()方法的线程。</span><br><span class="line"></span><br><span class="line">this.isInterrupted():测试线程Thread对象是否已经是中断状态，但不清除状态标志。</span><br></pre></td></tr></table></figure><h4 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h4><p>使用<code>suspend()</code>方法暂停线程，使用<code>resume()</code>方法恢复线程的执行。</p><p>缺点：独占，不同步</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。</p><p>设置线程优先级有助于帮“线程规划器”确定在下一次选择哪个线程来优先执行。</p><p>线程优先级分为<code>1~10</code>这10个等级，如果小于1或大于10，则JDK抛出异常<code>throw new IllegalArgumentException()</code>,</p><p>JDK使用3个常量来预置定义优先级的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static int MIN_PRIORITY = 1;</span><br><span class="line">public final static int NORM_PRIORITY = 5;</span><br><span class="line">public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure><p> 线程优先级具有继承性：A线程启动B线程，则B线程的优先级与A一样。</p><p> 高优先级的线程总是<code>大部分</code>先执行完，但不代表高优先线程全部先执行完。</p><p> 线程的优先级与代码的执行顺序无关。</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p> 在java线程中有两种线程，一种是用户线程，另一种是守护线程。</p><p> 任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，当进程中不存在非守护线程了，则守护线程自动销毁。</p><p> 典型的守护线程是：GC（垃圾回收器）</p><p> <code>thread.setDaemon(true)</code>：设置当前线程为守护线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：通过查看“windows任务管理器”中的列表，完全可以将运行在内存中的exe文件理解成进程。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java多线程编程核心技术| java多线程技能" scheme="http://yoursite.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="java多线程编程核心技术" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客源文件备份</title>
    <link href="http://yoursite.com/2017/11/11/Hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    <id>http://yoursite.com/2017/11/11/Hexo博客源文件备份/</id>
    <published>2017-11-11T04:49:00.000Z</published>
    <updated>2017-12-15T08:17:59.847Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用Hexo编写博客还是比较Nice的，但是有一个问题就是Hexo博客的源文件是放在本地的，如果换一台电脑更新博客或者源文件不小心丢失啦，那就麻烦啦。未雨绸缪，现在给出这一问题的解决方案。</p><h4 id="备份方案"><a href="#备份方案" class="headerlink" title="备份方案"></a>备份方案</h4><p>想到的办法：</p><ul><li><p>将博客源文件拷贝到U盘里—但是这样做，无法同步。</p></li><li><p>使用网盘的话，据说.git文件不能上传同步—而且我对国内的网盘也不放心。</p></li></ul><p>综合起来，我觉得比较流行的方法就是：</p><ul><li>将博客源文件托管到Github.</li></ul><h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><ul><li><p>在Github上创建一个新的repository ,名字为<code>hexohexo</code>。（与你的本地博客源文件文件名相同即可）</p></li><li><p>进入本地<code>hexohexo</code>文件夹,执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置远程仓库地址，并更新，本地文件夹与远程仓库绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:hanweizhe/hexohexo.git</span><br><span class="line">git pull orgin master</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>(<strong>非必须项</strong>) 修改<code>.gitignore</code>文件（如果没有就手动创建一个），在里面加入<code>.*.log</code>和<code>public/</code>以及<code>.deploy*/</code>。因为每次执行<code>hexo generate</code>命令时，上述目录都会被重写更新，因此忽略上述目录下的文件更新，加快push速度。</p></li><li><p>完成Hexo源码在本地的提交，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"添加Hexo源码文件作为备份"</span></span><br></pre></td></tr></table></figure></li><li><p>将本地仓库文件推送到Github，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>当远程仓库有更新时，执行以下命令，即可同步远程源代码文件到本地文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li></ul><p>现在在任何一台电脑上，只需要<code>git clone git@github.com:hanweizhe/hexoohexo.git</code> 即可将Hexo源文件复制到本地。（请将<code>git clone git@github.com:hanweizhe/hexohexo.git</code> 换成自己远程仓库地址）</p><p>在本地编写完博客时，顺序执行以下命令，即可完成Hexo博客源文件的同步更新，保持Github上的Hexo源码为最新的版本。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"更新Hexo源文件"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>至此，Hexo源代码文件就完成了同步与更新。</p><p>对于博主这种懒人，每次更新博文都需要输入两三行重复的git命令真是一件麻烦事，说不定哪天就忘记push到Github上啦。有没有更省事的办法？？完成自动备份 ？？</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用<code>NodeJs</code>的事件监听机制实现监听Hexo的<code>deployAfter</code>事件，待博客部署完成之后自动运行Git备份命令，以达到自动备份的目的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="将hexohexo目录加入Git仓库（见前面）。"><a href="#将hexohexo目录加入Git仓库（见前面）。" class="headerlink" title="将hexohexo目录加入Git仓库（见前面）。"></a>将hexohexo目录加入Git仓库（见前面）。</h5><h5 id="安装shelljs模块。"><a href="#安装shelljs模块。" class="headerlink" title="安装shelljs模块。"></a>安装<code>shelljs</code>模块。</h5><p>要实现这个自动备份功能，需要依赖NodeJs的一个<code>shelljs</code>模块，该模块重新包装啦<code>child_process</code><br> ,调用系统命令更加方便。该模块需要安装后使用。</p><p>键入以下命令，完成<code>shelljs</code>模块的安装：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save shelljs</span><br></pre></td></tr></table></figure><h5 id="编写自动备份脚本"><a href="#编写自动备份脚本" class="headerlink" title="编写自动备份脚本"></a>编写自动备份脚本</h5><p>待到模块安装完成，在<code>hexohexo</code>根目录的<code>scripts</code>文件夹下新建一个js文件，文件名字随意取。</p><p><strong>如果没有<code>scripts</code>目录，请新建一个。</strong></p><p>然后再脚本中，写入以下内容：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       hexo.on(<span class="string">'deployAfter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//当   deploy完成后执行备份</span></span><br><span class="line">           run();</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为："</span> + e.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!which(<span class="string">'git'</span>)) &#123;</span><br><span class="line">           echo(<span class="string">'Sorry, this script requires git'</span>);</span><br><span class="line">           exit(<span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           echo(<span class="string">"======================Auto Backup Begin==========================="</span>);</span><br><span class="line">           cd(<span class="string">'D:/hexohexo'</span>);    <span class="comment">//此处修改为   Hexo根目录路径</span></span><br><span class="line">           <span class="keyword">if</span> (exec(<span class="string">'git add --all'</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">               echo(<span class="string">'Error: Git add failed'</span>);</span><br><span class="line">               exit(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (exec(<span class="string">'git commit -am "Form auto backup script\'s commit"'</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">               echo(<span class="string">'Error: Git commit failed'</span>);</span><br><span class="line">               exit(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (exec(<span class="string">'git push origin master'</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">               echo(<span class="string">'Error: Git push failed'</span>);</span><br><span class="line">               exit(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           echo(<span class="string">"==================Auto Backup Complete============================"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>其中，需要修改地<code>15</code>行的<code>D:/hexohexo</code>路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径）；</li><li>如果你的Git远程仓库名称不为<code>origin</code>的话（默认为<code>origin</code>），还需要修改第<code>24</code>行执行的push命令，修改成自己的远程仓库名与相应的分支名。</li></ul><p>保存脚本并退出，然后执行<code>hexo deploy</code>命令，将会得到类似以下结果：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: git&gt;</span><br><span class="line">INFO  Clearing .deploy folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">[master 3020788] Site updated: 2015-07-06 15:08:06</span><br><span class="line"> 5 files changed, 160 insertions(+), 58 deletions(-)</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch gh-pages from git@github.com:smilexi</span><br><span class="line">amo/notes.git.</span><br><span class="line">To git@github.com:smilexiamo/notes.git</span><br><span class="line">   02adbe4..3020788  master -&gt; gh-pages</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch gitcafe-pages from git@gitcafe.com:s</span><br><span class="line">milexiamo/smilexiamo.git.</span><br><span class="line">To git@gitcafe.com:smilexiamo/smilexiamo.git</span><br><span class="line">   02adbe4..3020788  master -&gt; gitcafe-pages</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br><span class="line">======================Auto Backup Begin===========================</span><br><span class="line">[master f044360] Form auto backup script<span class="string">'s commit</span></span><br><span class="line"><span class="string"> 2 files changed, 35 insertions(+), 2 deletions(-)</span></span><br><span class="line"><span class="string"> rewrite db.json (100%)</span></span><br><span class="line"><span class="string">To git@github.com:smilexiamo/hexo.git</span></span><br><span class="line"><span class="string">   8f2b4b4..f044360  master -&gt; master</span></span><br><span class="line"><span class="string">==================Auto Backup Complete============================</span></span><br></pre></td></tr></table></figure><p>这样子，每次更新博客并<code>hexo deploy</code>到服务器上之后。备份就会自动启动并完成备份啦！~~~ 是不是很方便呀！</p><p>Enjoy it!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;使用Hexo编写博客还是比较Nice的，但是有一个问题就是Hexo博客的源文件是放在本地的，如果换一台电脑更新博客或者源文件不小心丢失啦，那
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="教程| Hexo教程 | Hexo源文件备份" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-Hexo%E6%95%99%E7%A8%8B-Hexo%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>用hexo极速搭建博客</title>
    <link href="http://yoursite.com/2017/11/10/%E7%94%A8hexo%E6%9E%81%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/11/10/用hexo极速搭建博客/</id>
    <published>2017-11-10T13:04:00.000Z</published>
    <updated>2017-11-11T06:26:31.520Z</updated>
    
    <content type="html"><![CDATA[<p>hexo是一个非常轻量且快速的博客生成框架，可以使用markdown便捷的生成文章。</p><p>本文主要介绍windows下如何搭建hexo5.1.3+环境并发布至github。默认读者具有命令行使用经验和一定的web编程基础。</p><p>hexo搭建完成后只需要三步就可以完成博文的更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n  <span class="comment"># 新建</span></span><br><span class="line">hexo g  <span class="comment"># 生成</span></span><br><span class="line">hexo d  <span class="comment"># 发布</span></span><br></pre></td></tr></table></figure><p>下面介绍windows下如何搭建hexo5.1.3环境并发布至github</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p>到<a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">node.js</a>官网下载node.js并安装。我使用的是win8.1x64下的8.9.1版。</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>git客户端很多，我使用的是git官方提供的工具，下载速度可能较慢。</p><h4 id="安装sublime（非必须）"><a href="#安装sublime（非必须）" class="headerlink" title="安装sublime（非必须）"></a>安装sublime（非必须）</h4><p>作为一个小前端，sublime作为编辑器实在是不能再好用，不过这个只是文本编辑器使用，大家可以根据喜好自由选择工具，切记不要使用windows自带的记事本。</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>我们使用Github官方提供的Github Pages这一服务作为静态博客的服务器。申请Github账户和与git通过ssh建立连接网上很多详细的教程，此处不再赘述。</p><p><a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="external">GitHub Help - Generating SSH Keys</a></p><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><p>node.js和git安装好后，建议使用git提供的命令行窗口进行操作。</p><p><strong> windows自带的cmd会报错。</strong></p><p>执行如下命令可安装hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="hexo初始化"><a href="#hexo初始化" class="headerlink" title="hexo初始化"></a>hexo初始化</h3><p>执行init命令初始化hexo到你指定的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;  <span class="comment">#folder为你指定的目录</span></span><br></pre></td></tr></table></figure><p>或者cd到你的指定目录，执行<strong> hexo init </strong></p><p>至此，hexo的安装工作已经完成。</p><h4 id="hexo必备插件"><a href="#hexo必备插件" class="headerlink" title="hexo必备插件"></a>hexo必备插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-index --save <span class="comment">#索引生成器</span></span><br><span class="line">$ npm install hexo-generator-archive --save <span class="comment">#归档生成器</span></span><br><span class="line">$ npm install hexo-generator-category --save <span class="comment">#分类生成器</span></span><br><span class="line">$ npm install hexo-generator-tag --save <span class="comment">#标签生成器</span></span><br><span class="line">$ npm install hexo-server --save <span class="comment">#本地服务</span></span><br><span class="line">$ npm install hexo-deploy-git --save <span class="comment">#hexo通过git发布（必装）</span></span><br><span class="line">$ npm install hexo-render-market@0.2.7 --save <span class="comment">#渲染器</span></span><br><span class="line">$ npm install hexo-render-stylus@0.3.0 --save <span class="comment">#渲染器</span></span><br></pre></td></tr></table></figure><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><p>cd至之前初始化的目录，执行如下命令，即可生成静态页面至public目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><p>执行如下命令，启动本地服务器，进行预览。<br>必须安装hexo-server插件，不然无法启动本地服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>浏览器输入localhost：4000即可访问默认的hexo博客效果。</p><p><strong> 注意：</strong> hosts文件中localhost是否被占用以及4000端口可能被福昕阅读器占用。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>编辑hexo根目录下的_config.yml文件，找到最下面的deploy，我使用的是hexo5.1.3为如下格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> <span class="built_in">type</span>: git</span><br><span class="line"> repo: https://github.com/hanweizhe/hanweizhe.hithub.io.git <span class="comment">#你的Github Pages的https链接</span></span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure><p>保存配置文件后，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p><strong> 注意： </strong>  yml格式文件冒号后面必须加一个空格。</p><p>执行完毕后访问hanweizhe.github.io即可看到部署在Github上的默认博客，第一次发布可能会有10分钟的延迟。</p><p>至此，hexo已经成功帮助我们生成了一个博客，非常的方便。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$　hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">$  hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">$  hexo generate <span class="comment">#根据source目录md文件生成静态页面至public目录</span></span><br><span class="line">$  hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl+c'关闭server）</span></span><br><span class="line">$  hexo deploy <span class="comment">#将.deploy目录部署到Github</span></span><br><span class="line">$  hexo <span class="built_in">help</span> <span class="comment">#查看帮助</span></span><br><span class="line">$  hexo vwesion <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><h4 id="简写："><a href="#简写：" class="headerlink" title="简写："></a>简写：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br><span class="line">hexo n == hexo new</span><br></pre></td></tr></table></figure><p>坑：</p><ol><li>有时会出现首页只有一篇文章的情况，这个时候需要hexo渲染两次，原因不明。</li><li>标题中不能含有[]，否则无法编译。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hexo是一个非常轻量且快速的博客生成框架，可以使用markdown便捷的生成文章。&lt;/p&gt;
&lt;p&gt;本文主要介绍windows下如何搭建hexo5.1.3+环境并发布至github。默认读者具有命令行使用经验和一定的web编程基础。&lt;/p&gt;
&lt;p&gt;hexo搭建完成后只需要三
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="教程| Hexo教程 | Hexo快速搭建" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-Hexo%E6%95%99%E7%A8%8B-Hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/10/hello-world/"/>
    <id>http://yoursite.com/2017/11/10/hello-world/</id>
    <published>2017-11-10T10:34:11.806Z</published>
    <updated>2017-11-10T07:46:41.732Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
