<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的第一个博客</title>
  
  <subtitle>xia1769655343@hotmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-28T07:37:56.869Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>夏茂盛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis配置文件详解(第十五部分)</title>
    <link href="http://yoursite.com/2018/02/28/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3(%E7%AC%AC%E5%8D%81%E4%BA%94%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/28/redis配置文件详解(第十五部分)/</id>
    <published>2018-02-28T06:46:55.000Z</published>
    <updated>2018-02-28T07:37:56.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置文件全解和命令"><a href="#配置文件全解和命令" class="headerlink" title="配置文件全解和命令"></a>配置文件全解和命令</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h5><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">daemonize no</td><td style="text-align:left">是否以后台进程启动</td></tr><tr><td style="text-align:left">databases 16</td><td style="text-align:left">创建database的数量(默认选中的是database 0)</td></tr><tr><td style="text-align:left">save 900 1</td><td style="text-align:left">刷新快照到硬盘中，必须满足两者要求才会触发，即900秒之后至少1个关键字发生变化</td></tr><tr><td style="text-align:left">save 300 10</td><td style="text-align:left">必须是300秒之后至少10个关键字发生变化</td></tr><tr><td style="text-align:left">save 60 10000</td><td style="text-align:left">必须是60秒之后至少10000个关键字发生变化</td></tr><tr><td style="text-align:left">stop-writes-on-bgsave-error yes</td><td style="text-align:left">后台存储错误停止写</td></tr><tr><td style="text-align:left">rdbcompression yes</td><td style="text-align:left">使用LZF压缩rdb文件</td></tr><tr><td style="text-align:left">rdbchecksum yes</td><td style="text-align:left">存储和加载rdb文件时校验</td></tr><tr><td style="text-align:left">dbfilename dump.rdb</td><td style="text-align:left">设置rdb文件名</td></tr><tr><td style="text-align:left">dir ./</td><td style="text-align:left">设置工作目录，rdb文件会写入该目录</td></tr></tbody></table><h5 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h5><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">slaveof <masterip> <masterport></masterport></masterip></td><td style="text-align:left">设为某台机器的从服务器</td></tr><tr><td style="text-align:left">masterauth <master-password></master-password></td><td style="text-align:left">连接主服务器的密码</td></tr><tr><td style="text-align:left">slave-serve-stale-data yes</td><td style="text-align:left">当主从断开或正在复制中,从服务器是否应答</td></tr><tr><td style="text-align:left">slave-read-only yes</td><td style="text-align:left">从服务器只读</td></tr><tr><td style="text-align:left">repl-ping-slave-period 10</td><td style="text-align:left">从ping主的时间间隔,秒为单位</td></tr><tr><td style="text-align:left">repl-timeout 60</td><td style="text-align:left">主从超时时间(超时认为断线了),要比period大</td></tr><tr><td style="text-align:left">slave-priority 100</td><td style="text-align:left">如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master</td></tr><tr><td style="text-align:left">repl-disable-tcp-nodelay no</td><td style="text-align:left">主端是否合并数据,大块发送给slave</td></tr></tbody></table><h5 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h5><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">requirepass 密码</td><td style="text-align:left">设置密码</td></tr><tr><td style="text-align:left">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</td><td style="text-align:left">如果公共环境,可以重命名部分敏感命令 如config</td></tr></tbody></table><h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">maxclients 10000</td><td style="text-align:left">最大连接数</td></tr><tr><td style="text-align:left">maxmemory <bytes></bytes></td><td style="text-align:left">最大使用内存</td></tr><tr><td style="text-align:left">maxmemory-policy volatile-lru</td><td style="text-align:left">内存到极限后的处理</td></tr><tr><td style="text-align:left">volatile-lru</td><td style="text-align:left">LRU算法删除过期key</td></tr><tr><td style="text-align:left">allkeys-lru</td><td style="text-align:left">LRU算法删除key(不区分过不过期)</td></tr><tr><td style="text-align:left">volatile-random</td><td style="text-align:left">随机删除过期key</td></tr><tr><td style="text-align:left">allkeys-random</td><td style="text-align:left">随机删除key(不区分过不过期)</td></tr><tr><td style="text-align:left">volatile-ttl</td><td style="text-align:left">删除即将(快)过期的key</td></tr><tr><td style="text-align:left">noeviction</td><td style="text-align:left">不删除,返回错误信息</td></tr><tr><td style="text-align:left">maxmemory-samples 3</td><td style="text-align:left">每次进行淘汰时随机选择3个key，从里面淘汰最不经常使用的(默认选项)</td></tr></tbody></table><p><strong>解释</strong>:LRU ttl都是近似算法,可以选N个,再比较最适宜T踢出的数据</p><h5 id="日志模式"><a href="#日志模式" class="headerlink" title="日志模式"></a>日志模式</h5><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">appendonly no</td><td style="text-align:left">是否仅要日志</td></tr><tr><td style="text-align:left">appendfsync no</td><td style="text-align:left">系统缓冲,统一写,速度快</td></tr><tr><td style="text-align:left">appendfsync always</td><td style="text-align:left">系统不缓冲,直接写,慢,丢失数据少</td></tr><tr><td style="text-align:left">appendfsync everysec</td><td style="text-align:left">折衷,每秒写1次</td></tr><tr><td style="text-align:left">no-appendfsync-on-rewrite no</td><td style="text-align:left">为yes,则其他线程的数据放内存里,合并写入(速度快,容易丢失的多)</td></tr><tr><td style="text-align:left">auto-AOF-rewrite-percentage 100</td><td style="text-align:left">当前aof文件比上次重写大N%时重写</td></tr><tr><td style="text-align:left">auto-AOF-rewrite-min-size 64mb</td><td style="text-align:left">aof重写至少要达到的大小</td></tr></tbody></table><h5 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h5><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">slowlog-log-slower-than 10000</td><td style="text-align:left">记录响应时间大于10000微秒的慢查询</td></tr><tr><td style="text-align:left">slowlog-max-len 128</td><td style="text-align:left">最多记录128条</td></tr></tbody></table><h4 id="服务端命令"><a href="#服务端命令" class="headerlink" title="服务端命令"></a>服务端命令</h4><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">time</td><td style="text-align:left">返回时间戳+微秒</td></tr><tr><td style="text-align:left">dbsize</td><td style="text-align:left">返回key的数量</td></tr><tr><td style="text-align:left">bgrewriteaof</td><td style="text-align:left">重写aof</td></tr><tr><td style="text-align:left">bgsave</td><td style="text-align:left">后台开启子进程dump数据</td></tr><tr><td style="text-align:left">save</td><td style="text-align:left">同步rdb保存，阻塞进程dump数据</td></tr><tr><td style="text-align:left">lastsave</td><td style="text-align:left">返回最近一次redis成功将数据保存到磁盘上的时间</td></tr><tr><td style="text-align:left">slaveof host port</td><td style="text-align:left">做host port的从服务器(数据清空,复制新主内容)</td></tr><tr><td style="text-align:left">slaveof no one</td><td style="text-align:left">变成主服务器(原数据不丢失,一般用于主服失败后)</td></tr><tr><td style="text-align:left">flushdb</td><td style="text-align:left">清空当前数据库的所有数据</td></tr><tr><td style="text-align:left">flushall</td><td style="text-align:left">清空所有数据库的所有数据(误用了怎么办?)</td></tr><tr><td style="text-align:left">shutdown [save/nosave]</td><td style="text-align:left">关闭服务器,保存数据,修改AOF(如果设置)</td></tr><tr><td style="text-align:left">slowlog get</td><td style="text-align:left">获取慢查询日志</td></tr><tr><td style="text-align:left">slowlog len</td><td style="text-align:left">获取慢查询日志条数</td></tr><tr><td style="text-align:left">slowlog reset</td><td style="text-align:left">清空慢查询</td></tr><tr><td style="text-align:left">info all</td><td style="text-align:left">返回redis服务器各种信息和统计数值</td></tr><tr><td style="text-align:left">config get 选项(支持*通配)</td><td style="text-align:left">获得配置文件选项值</td></tr><tr><td style="text-align:left">config set 选项 值</td><td style="text-align:left">设置配置文件选项值</td></tr><tr><td style="text-align:left">config rewrite</td><td style="text-align:left">把值写到配置文件</td></tr><tr><td style="text-align:left">config restart</td><td style="text-align:left">更新info命令的信息</td></tr><tr><td style="text-align:left">debug object key</td><td style="text-align:left">调试选项,看一个key的情况</td></tr><tr><td style="text-align:left">debug segfault</td><td style="text-align:left">模拟段错误,让服务器崩溃</td></tr><tr><td style="text-align:left">object key (refcount</td><td style="text-align:left">encoding</td><td>idletime)</td><td></td></tr><tr><td style="text-align:left">monitor</td><td style="text-align:left">打开控制台,观察命令(调试用)</td></tr><tr><td style="text-align:left">client list</td><td style="text-align:left">列出所有连接</td></tr><tr><td style="text-align:left">client kill</td><td style="text-align:left">杀死某个连接  CLIENT KILL 127.0.0.1:43501</td></tr><tr><td style="text-align:left">client getname</td><td style="text-align:left">获取连接的名称 默认nil</td></tr><tr><td style="text-align:left">client setname “名称”</td><td style="text-align:left">设置连接名称,便于调试</td></tr></tbody></table><h4 id="连接命令"><a href="#连接命令" class="headerlink" title="连接命令"></a>连接命令</h4><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">auth 密码</td><td style="text-align:left">密码登陆(如果有密码)</td></tr><tr><td style="text-align:left">ping</td><td style="text-align:left">测试服务器是否可用</td></tr><tr><td style="text-align:left">echo “some content”</td><td style="text-align:left">测试服务器是否正常交互</td></tr><tr><td style="text-align:left">select 0/1/2…</td><td style="text-align:left">选择数据库</td></tr><tr><td style="text-align:left">quit</td><td style="text-align:left">退出连接</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;配置文件全解和命令&quot;&gt;&lt;a href=&quot;#配置文件全解和命令&quot; class=&quot;headerlink&quot; title=&quot;配置文件全解和命令&quot;&gt;&lt;/a&gt;配置文件全解和命令&lt;/h3&gt;&lt;h4 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis配置文件详解" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>redis中key的设计技巧(第十四部分)</title>
    <link href="http://yoursite.com/2018/02/28/redis%E4%B8%ADkey%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7(%E7%AC%AC%E5%8D%81%E5%9B%9B%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/28/redis中key的设计技巧(第十四部分)/</id>
    <published>2018-02-28T03:45:37.000Z</published>
    <updated>2018-02-28T05:20:53.548Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis-key-设计技巧"><a href="#Redis-key-设计技巧" class="headerlink" title="Redis key 设计技巧"></a>Redis key 设计技巧</h4><p>关系型数据库转化为分布式数据库：</p><ol><li>把表名转换为key前缀 如tag:</li><li>第2段放置用于区分key的字段–对应mysql中的主键的列名,如userid</li><li>第3段放置主键值,如2,3,4…., a , b ,c</li><li>第4段,写要存储的列名</li></ol><p>用户表 user转换为key-value存储:</p><table><thead><tr><th style="text-align:center">userid</th><th style="text-align:center">username</th><th style="text-align:center">passworde</th><th style="text-align:center">email</th></tr></thead><tbody><tr><td style="text-align:center">9</td><td style="text-align:center">Lisi</td><td style="text-align:center">1111111</td><td style="text-align:center">lisi@163.com</td></tr></tbody></table><p>设计：<br>set  user:userid:9:username  lisi<br>set  user:userid:9:password  111111<br>set  user:userid:9:email  lisi@163.com<br>查询所有存储的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys user:userid:9*</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>:<br>在分布式数据库中，我们是按主键进行存储的。除主键外,还有可能其他列也需要查询,如上表中, username 也是极频繁查询的,往往这种列也是加了索引的.那么该如何实现呢？？<br>keys user:userid:*:username:lisi 查询所有username为lisi的userid，如果数据太多，这个方法可能导致效率低下，有没有更高的方法呢？？<br>转换到k-v数据中,则也要相应的生成一条按照该列为主的key-value<br>冗余信息维护set user:username:lisi:userid  9<br>那，其他列也需要创建key-value吗?不需要!<br>这样,我们可以根据user:username:lisi:userid ,查出userid=9,<br>再查其他字段信息user:username:9:password/email …<br>完成了根据用户名来查询用户信息。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Redis-key-设计技巧&quot;&gt;&lt;a href=&quot;#Redis-key-设计技巧&quot; class=&quot;headerlink&quot; title=&quot;Redis key 设计技巧&quot;&gt;&lt;/a&gt;Redis key 设计技巧&lt;/h4&gt;&lt;p&gt;关系型数据库转化为分布式数据库：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis中key的设计技巧" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E4%B8%ADkey%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>redis主从切换(第十三部分)</title>
    <link href="http://yoursite.com/2018/02/09/redis%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2(%E7%AC%AC%E5%8D%81%E4%B8%89%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/09/redis主从切换(第十三部分)/</id>
    <published>2018-02-09T06:52:09.000Z</published>
    <updated>2018-02-28T02:13:16.863Z</updated>
    
    <content type="html"><![CDATA[<p>redis主从复制可将主节点数据同步给从节点，一旦主节点宕机，某一从节点晋升为主节点，并且还需要把只读配置修改为可写，其余从节点重新指向新的主节点。那么该如何操作呢？？不着急！很简单！！哦哦哦！！</p><h5 id="人工干预"><a href="#人工干预" class="headerlink" title="人工干预"></a>人工干预</h5><p>我的master是6379；slave是6380和6381；当6379宕机后，6380为主节点，6381为从节点。<br>在6380客户端进行操作:<strong>slave no one</strong>,将6380设置为主节点，<strong>config set slave-read-only no</strong>将6380设置为可写。<br>在6381客户端进行操作：<strong>slaveof localhost 6380</strong>将主节点设置为6380。<br>经过上面3步操作即可完成主从切换，是不是很简单呢？<br>思考一下，redis主机宕机属于随机，不确定，能不能自动监控进行主从切换呢？redis给出来解决方案，那就是<strong>redis sentinel</strong>。</p><h5 id="redis-sentinel"><a href="#redis-sentinel" class="headerlink" title="redis sentinel"></a>redis sentinel</h5><p>redis sentinel是一个分布式架构，包含若干个sentinel节点和redis数据节点，每个sentinel节点会对数据节点和其余的sentinel节点进行监控，当发现节点不可用时，会对相应的节点进行下线标识。<br>如果被标识的节点为master，它会和其余的sentinel节点进行协商，当大部分的sentinel节点都认为master不可用时，他们按照slave优先级(可配置 slave-priority,默认为100)，选出一个sentinel节点来完成主从切换操作，同时将这个变化通知给redis应用方。<br><img src="/image/redis3.png" alt="redis主从切换"><br>如果被标识的节点为slave，直接通知master去除该slave。<br><strong>疑问</strong>: sentinel与master通信,如果某次因为master IO操作频繁,导致超时,此时,认为master失效,很武断。<br>解决: sentnel允许多个实例看守1个master, 当N台(N可设置)sentinel都认为master失效,才正式失效。<br><strong>sentinel选项配置(sentinel.conf)</strong>:<br>port 26379 # 端口<br>sentinel monitor mymaster 127.0.0.1 6379 2 #mymaster是master的别名，127.0.0.1 6379是当前sentinel节点监控的master，2代表判断master宕机至少需要2个sentinel节点同意。<br>sentinel down-after-milliseconds mymaster 30000  #多少毫秒后连接不到master认为宕机。<br>sentinel can-failover mymaster yes  #是否允许sentinel修改此slave为master. 如为no,则只能监控,无权修改.一般只允许一个sentinel进行修改。<br>sentinel parallel-syncs mymaster 1  #一次性修改几个slave指向新的master，每次向新的master发起复制操作的slave个数。<br>我的部署:</p><table><thead><tr><th style="text-align:center">role</th><th style="text-align:center">IP</th><th style="text-align:center">port</th></tr></thead><tbody><tr><td style="text-align:center">master</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">6379</td></tr><tr><td style="text-align:center">slave</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">6380</td></tr><tr><td style="text-align:center">slave</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">6381</td></tr><tr><td style="text-align:center">sentinel1</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">26379</td></tr><tr><td style="text-align:center">sentinel2</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">26380</td></tr><tr><td style="text-align:center">sentinel3</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">26381</td></tr></tbody></table><p><strong>sentinel启动</strong>:<br>两种方法：</p><ol><li>redis-sentinel sentinel.conf</li><li>redis-server sentinel.conf –sentinel</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis主从复制可将主节点数据同步给从节点，一旦主节点宕机，某一从节点晋升为主节点，并且还需要把只读配置修改为可写，其余从节点重新指向新的主节点。那么该如何操作呢？？不着急！很简单！！哦哦哦！！&lt;/p&gt;
&lt;h5 id=&quot;人工干预&quot;&gt;&lt;a href=&quot;#人工干预&quot; clas
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis主从切换" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>redis运维命令(第十二部分)</title>
    <link href="http://yoursite.com/2018/02/09/redis%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4(%E7%AC%AC%E5%8D%81%E4%BA%8C%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/09/redis运维命令(第十二部分)/</id>
    <published>2018-02-09T02:20:52.000Z</published>
    <updated>2018-02-09T03:09:20.944Z</updated>
    
    <content type="html"><![CDATA[<p>redis的一些运维命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6380&gt; time  //显示服务器时间</span><br><span class="line">1) &quot;1375270361&quot; //时间戳(秒)</span><br><span class="line">2) &quot;504511&quot;   //时间戳(微秒数)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6380&gt; dbsize  // 查看当前数据库的key的数量</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6380&gt; select 2</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6380[2]&gt; dbsize</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof  后台进程重写AOF</span><br><span class="line">bgsave       后台保存rdb快照</span><br><span class="line">save         保存rdb快照</span><br><span class="line">lastsave     上次保存时间</span><br><span class="line">slaveof master-host port  把当前实例设为master的slave</span><br><span class="line">slaveof no one  把当前实例slave变为mater，关闭复制功能，原来同步数据不会丢失(上面两个命令一般一起使用:主机宕机)</span><br><span class="line">flushall  清空所有库所有键 </span><br><span class="line">flushdb   清空当前库所有键</span><br><span class="line">shutdown [save/nosave]  关闭客户端，save，刷新aof文件，关闭redis服务进程</span><br><span class="line">slowlog len  查询slowlog总条数</span><br><span class="line">slowlog get [number]  打印所有(指定数量)slowlog</span><br><span class="line">slowlog reset  清空slowlog</span><br><span class="line">config get 配置项  动态获得配置文件中配置项的值</span><br><span class="line">config set 配置项 值  动态设置配置文件中配置项的值(特殊的选项,不允许用此命令设置,如slave-of, 需要用单独的slaveof命令来设置)</span><br><span class="line">Info [Replication/CPU/Memory..]  查看redis服务器的信息</span><br></pre></td></tr></table></figure><p><strong>注</strong>: 如果不小心运行了flushall,立即shutdown nosave,关闭服务器.然后手工编辑aof文件,去掉文件中的”flushall”相关行,然后开启服务器,就可以导入回原来数据.<br>不幸的是,如果flushall之后,系统恰好bgrewriteaof了,那么aof就清空了,数据丢失.<br><strong>slowlog</strong>:用于记录<strong>慢查询执行时间</strong>(单单是执行一个查询命令所耗费时间)的日志系统，由于slowlog保存在内存中，所以slowlog的效率很高。<br><strong>注</strong>:</p><ol><li>多慢才叫慢?<br>答: 由slowlog-log-slower-than 10000 ,来指定slowlog的界限(单位是微秒)，只有query执行时间大于定义的才会定义成慢查询，才会被slowlog进行记录。</li><li>服务器储存多少条慢查询的记录?<br>答: 由 slowlog-max-len 128 ,来做限制，当slowlog超过设定的最大值后，会将最早的slowlog删除，是个FIFO队列。</li></ol><p><strong>redis运维时需要注意的参数</strong>:</p><ol><li>内存Memory<br>used_memory:859192  数据结构的空间<br>used_memory_rss: 7634944 实占空间<br>mem_fragmentation_ratio:8.89 前2者的比例,1.N为佳,如果此值过大,说明redis的内存的碎片化严重,可以导出再导入一次.</li><li>主从复制Replication<br>role:slave<br>master_host:192.168.17.128<br>master_port:6379<br>master_link_status:up  </li><li>持久化Persistence<br>rdb_changes_since_last_save:0<br>rdb_last_save_time:1375224063  </li><li>耗时fork<br>latest_fork_usec:936  上次导出rdb快照,持久化花费微秒<br><strong>注意</strong>: 如果某实例有10G内容,导出需要2分钟,每分钟写入10000次,导致不断的rdb导出,磁盘始处于高IO状态.</li><li>慢日志slowlog<br>config get/set slowlog-log-slower-than<br>config get/set slowlog-max-len<br>slowlog get N 获取慢日志</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis的一些运维命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis运维命令" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>redis集群(第十一部分)</title>
    <link href="http://yoursite.com/2018/02/08/redis%E9%9B%86%E7%BE%A4(%E7%AC%AC%E5%8D%81%E4%B8%80%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/08/redis集群(第十一部分)/</id>
    <published>2018-02-08T03:42:32.000Z</published>
    <updated>2018-02-08T05:20:44.436Z</updated>
    
    <content type="html"><![CDATA[<h5 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h5><ol><li>主从备份(防止主机宕机)</li><li>读写分离(主机写，从机读，分担master的任务)</li><li>任务分离(服务器分别分担备份工作与计算工作)</li></ol><h5 id="redis主从备份原理及通信过程"><a href="#redis主从备份原理及通信过程" class="headerlink" title="redis主从备份原理及通信过程"></a>redis主从备份原理及通信过程</h5><p><strong>主从备份原理图</strong></p><p><img src="/image/redis1.png" alt="redis主从备份原理图"></p><p>第2种方式的好处:<br>master宕机后,可以直接切换到slave1，不需要slave2重新指向slave1.</p><p><strong>主从通信过程</strong>：</p><p><img src="/image/redis2.png" alt="redis主从通信过程"></p><h5 id="redis主从集群配置："><a href="#redis主从集群配置：" class="headerlink" title="redis主从集群配置："></a>redis主从集群配置：</h5><p><strong>Master配置</strong>:</p><ol><li>关闭rdb快照(备份工作交给slave)。</li><li>可以开启aof。</li></ol><p><strong>slave配置</strong>:</p><ol><li>声明slave-of。</li><li>配置密码[如果master有密码]。</li><li>[某1个]slave打开 rdb快照功能。</li><li>配置是否只读[slave-read-only]。</li><li>改变端口。</li></ol><p>我的是 6379端口作为master；6380，6381作为slave.<br>     6379关闭rdb持久化，开启aof持久化<br>     6380开启rdb持久化，关闭aof持久化<br>     6381关闭rdb持久化，开启aof持久化<br><strong>运行结果</strong>：(没有设置密码)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[centos@localhost bin]$ ./redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set aa 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get aa</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[centos@localhost bin]$ ./redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; get aa</span><br><span class="line">&quot;123&quot;</span><br><span class="line">127.0.0.1:6380&gt; set aa</span><br><span class="line">(error) ERR wrong number of arguments for &apos;set&apos; command</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[centos@localhost bin]$ ./redis-cli -p 6381</span><br><span class="line">127.0.0.1:6381&gt; get aa</span><br><span class="line">&quot;123&quot;</span><br><span class="line">127.0.0.1:6381&gt; set aa</span><br><span class="line">(error) ERR wrong number of arguments for &apos;set&apos; command</span><br></pre></td></tr></table></figure><p>那么该如何<strong>设置密码</strong>呢？<br>master：requirepass 123<br>slave： masterauth 123<br>      requireauth 123<br>如果主从服务器密码不一致，从服务器无法获得主服务器数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[centos@localhost bin]$ ./redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set cc 123</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set cc 123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[centos@localhost bin]$ ./redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; get cc</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6380&gt; auth 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get cc</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure><p><strong>redis主从复制的缺陷</strong>：<br>每次slave断开后(无论是主动断开,还是网络故障)，再连接master，都要master全部dump出来rdb,再aof,即同步的过程都要重新执行1遍.<br>所以要<strong>记住</strong>—多台slave不要一下都启动起来,否则master可能IO剧增。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;redis集群&quot;&gt;&lt;a href=&quot;#redis集群&quot; class=&quot;headerlink&quot; title=&quot;redis集群&quot;&gt;&lt;/a&gt;redis集群&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;主从备份(防止主机宕机)&lt;/li&gt;
&lt;li&gt;读写分离(主机写，从机读，分担master的
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 |  redis集群" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>redis持久化(第十部分)</title>
    <link href="http://yoursite.com/2018/02/07/redis%E6%8C%81%E4%B9%85%E5%8C%96(%E7%AC%AC%E5%8D%81%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/07/redis持久化(第十部分)/</id>
    <published>2018-02-07T07:58:35.000Z</published>
    <updated>2018-02-09T03:36:25.963Z</updated>
    
    <content type="html"><![CDATA[<p>所谓持久化就是把数据存储于断电后不会丢失的设备中，通常是硬盘。<br>Redis的持久化有2种方式:  </p><ol><li>rdb快照持久化：将数据库的快照以二进制的方式保存到磁盘中。  </li><li>aof日志持久化：将所有对数据库进行写入的命令(及其参数)记录到aof文件中，以达到记录数据库状态的目的。</li></ol><h5 id="rdb快照持久化"><a href="#rdb快照持久化" class="headerlink" title="rdb快照持久化"></a>rdb快照持久化</h5><p>rdb的工作原理：每隔<strong>‘N分钟N个关键字’</strong>发生变化后，从内存dump数据形成rdb文件，<strong>‘压缩’</strong>，放在<strong>‘备份目录’</strong>。<br><strong>注</strong>：上面带引号的粗体都可以进行配置。<br>rdb快照的配置选项：(redis.conf配置文件)<br>save 60 10000  // 如果60秒内有10000个关键字发生变化,则产生快照。<br>save 300 1000  // 如果300秒内有1000个关键字发生变化,则产生快照。<br>save 900 1    //如果900秒内有1个关键字发生变化,则产生快照。<br>(这3个选项都屏蔽,则rdb禁用)<br><strong>小技巧</strong>：redis-benchmark -n 10000 //利用redis的测试工具一次执行10000个命令。<br>刷新快照到硬盘中，必须满足两者(时间，关键字发生变化的数量)要求才会触发。<br>stop-writes-on-bgsave-error yes  // 后台备份进程出错时,主进程是否停止写入。<br>rdbcompression yes    // 导出的rdb文件是否压缩。<br>rdbchecksum yes     // 导入rbd恢复数据时,要不要检验rdb的完整性。<br>dbfilename dump.rdb  //导出来的rdb文件名。<br>dir ./  //rdb的放置路径目录<br><strong>缺陷</strong>：在两个保存点之间断电，刚修改的有些数据还没有达到备份时间，将会丢失1—N分钟的数据。  </p><h5 id="aof日志持久化"><a href="#aof日志持久化" class="headerlink" title="aof日志持久化"></a>aof日志持久化</h5><p>aof (append only file)的配置<br>appendonly no # 是否打开aof日志功能。</p><p>appendfsync always # 每1个命令,都立即同步到aof. 安全,速度慢。<br>appendfsync everysec # 折衷方案,每秒写1次。<br>appendfsync no # 写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof.同步频率低,速度快。  </p><p>no-appendfsync-on-rewrite yes: # 正在导出rdb快照的过程中,要不要停止同步aof。<br>auto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小,增长率100%时,重写。<br>auto-aof-rewrite-min-size 64mb #aof文件,至少超过64M时,重写。<br>(上面这两个条件增长率及文件大小同时满足时触发自动的aof重写)<br><strong>另外</strong>: aof重写也可以由用户调用BGREWRITEAOF手动触发。<br><strong>小技巧</strong>：ll  -h  //查看文件夹下文件大小  </p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol><li>在dump rdb过程中,aof如果停止同步,会不会丢失?<br>答: 不会,所有的操作缓存在内存的队列里, dump完成后,统一操作。</li><li>aof重写是指什么?<br>答: aof重写是指把内存中的数据逆化成命令,写入到aof日志里.以解决aof日志过大的问题。</li><li>如果rdb文件,和aof文件都存在,优先用谁来恢复数据?<br>答: aof。</li><li>开始rdb文件有内容，开启aof选项，重启redis，为什么现在redis中没有数据啦？<br>答:开启aof选项，产生一个空的aof文件，rdb和aof文件都有，优先用aof(空)文件来恢复数据。</li><li>2种(rdb快照持久化与aof日志持久化)是否可以同时用?<br>答: 可以,而且推荐这么做。</li><li>恢复时rdb和aof哪个恢复的快？<br>答: rdb快,因为其是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行。</li><li>原来一个key值为1，对同一个key操作100次(假如每次增加1)，最后key的值为101，aof产生100行记录,aof文件会很大,怎么解决?恢复的时候一条一条执行慢，为什么不直接执行最后一条命令？<br>答: aof重写就是为了把那些重复命令精简成几条命令进行重新写入aof文件。</li></ol><h5 id="报错权限问题"><a href="#报错权限问题" class="headerlink" title="报错权限问题"></a>报错权限问题</h5><p>chmod -R 777 bin</p><ol><li>添加aof功能后,可能redis服务启动不起来，把存放aof文件的权限修改一下就行.</li><li>redis在shutdown的时候,会进行save操作,而save操作需要dump.rdb文件,如果没有权限会报错误</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓持久化就是把数据存储于断电后不会丢失的设备中，通常是硬盘。&lt;br&gt;Redis的持久化有2种方式:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rdb快照持久化：将数据库的快照以二进制的方式保存到磁盘中。  &lt;/li&gt;
&lt;li&gt;aof日志持久化：将所有对数据库进行写入的命令(及其参数)
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 |  redis持久化" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>redis消息订阅(第九部分)</title>
    <link href="http://yoursite.com/2018/02/07/redis%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85(%E7%AC%AC%E4%B9%9D%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/07/redis消息订阅(第九部分)/</id>
    <published>2018-02-07T05:27:56.000Z</published>
    <updated>2018-02-07T05:31:07.953Z</updated>
    
    <content type="html"><![CDATA[<p>使用办法:<br><strong>订阅端</strong>: subscribe 频道名称<br><strong>发布端</strong>: publish 频道名称 发布内容<br>服务端例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; publish news &apos;good good study&apos;</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; publish news &apos;day day up&apos;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p><p>客户端例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; subscribe news</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;news&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;news&quot;</span><br><span class="line">3) &quot;good good study&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;news&quot;</span><br><span class="line">3) &quot;day day up&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psubscribe new*</span><br></pre></td></tr></table></figure><p>根据匹配模式一次性监听多个频道.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用办法:&lt;br&gt;&lt;strong&gt;订阅端&lt;/strong&gt;: subscribe 频道名称&lt;br&gt;&lt;strong&gt;发布端&lt;/strong&gt;: publish 频道名称 发布内容&lt;br&gt;服务端例子:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis消息订阅" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85/"/>
    
  </entry>
  
  <entry>
    <title>redis的事务(第八部分)</title>
    <link href="http://yoursite.com/2018/02/07/redis%E7%9A%84%E4%BA%8B%E5%8A%A1(%E7%AC%AC%E5%85%AB%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/07/redis的事务(第八部分)/</id>
    <published>2018-02-07T03:03:56.000Z</published>
    <updated>2018-02-07T03:16:07.257Z</updated>
    
    <content type="html"><![CDATA[<p>Redis支持简单的事务<br>Redis与 mysql事务的对比:</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Mysql</th><th style="text-align:center">Redis</th></tr></thead><tbody><tr><td style="text-align:center">开启</td><td style="text-align:center">start transaction</td><td style="text-align:center">multi</td></tr><tr><td style="text-align:center">语句</td><td style="text-align:center">普通sql</td><td style="text-align:center">普通命令</td></tr><tr><td style="text-align:center">失败</td><td style="text-align:center">rollback 回滚</td><td style="text-align:center">discard 取消</td></tr><tr><td style="text-align:center">成功</td><td style="text-align:center">commit</td><td style="text-align:center">exec</td></tr></tbody></table><p><strong>注</strong>: rollback与discard 的区别:<br>如果已经成功执行了2条语句, 第3条语句出错.<br>Rollback后,前2条的语句影响消失.<br>Discard只是结束本次事务,前2条语句造成的影响仍然还在.<br>注:<br>在multi后面的语句中, 语句出错可能有2种情况:</p><ol><li>语法就有问题, 这种exec时报错, 所有语句得不到执行.</li><li>语法本身没错,但适用对象有问题. 比如 zadd 操作list对象,Exec之后,会执行正确的语句,并跳过有不适当的语句.<br>(如果zadd操作list这种事怎么避免? 这一点,由程序员负责)</li></ol><p><strong>思考</strong>:<br>我正在买票<br>Ticket -1 , money -100<br>而票只有1张, 如果在我multi之后,和exec之前, 票被别人买了—即ticket变成0了.<br>我该如何观察这种情景,并不再提交.<br><strong>悲观的想法</strong>:<br>世界充满危险,肯定有人和我抢, 给 ticket上锁, 只有我能操作. [<strong>悲观锁</strong>]<br><strong>乐观的想法</strong>:<br>世界美好,没有那么人和我抢,因此,我只需要注意,有没有人更改ticket的值就可以了.[<strong>乐观锁</strong>]<br><strong>Redis的事务中,启用的是乐观锁,只负责监测key没有被改动.</strong><br>具体的命令—-  watch命令<br>例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; watch ticket</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; decr ticket</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:6379&gt; decrby money 100</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:6379&gt; exec</span><br><span class="line">(nil)   // 返回nil,说明监视的ticket已经改变了,事务就取消了.</span><br><span class="line">redis 127.0.0.1:6379&gt; get ticket</span><br><span class="line">&quot;0&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; get money</span><br><span class="line">&quot;200&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 key2  ... keyN</span><br></pre></td></tr></table></figure><p>作用:监听key1 key2..keyN有没有变化,如果有变,则事务取消.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure></p><p>作用: 取消watch命令对于所有key的监听.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis支持简单的事务&lt;br&gt;Redis与 mysql事务的对比:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Mysql&lt;/th&gt;

      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis的事务" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>redis对于hashes 哈希类型的操作(第七部分)</title>
    <link href="http://yoursite.com/2018/02/06/redis%E5%AF%B9%E4%BA%8Ehashes%20%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C(%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/06/redis对于hashes 哈希类型的操作(第七部分)/</id>
    <published>2018-02-06T09:42:28.000Z</published>
    <updated>2018-02-06T09:47:31.044Z</updated>
    
    <content type="html"><![CDATA[<p>可以将redis中的hashes类型看成具有String key和String value的map容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure></p><p>作用: 把key中 field域的值设为value。<br><strong>注</strong>:如果没有field域,直接添加,如果有,则覆盖原field域的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 [field2 value2 field3 value3 ......fieldn valuen]</span><br></pre></td></tr></table></figure></p><p>作用: 设置field1-&gt;N 个域, 对应的值是value1-&gt;N。<br>(对应PHP理解为  $key = array(file1=&gt;value1, field2=&gt;value2 ….fieldN=&gt;valueN))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br></pre></td></tr></table></figure></p><p>作用: 返回key中field域的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2 fieldN</span><br></pre></td></tr></table></figure></p><p>作用: 返回key中field1 field2 fieldN域的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure></p><p>作用:返回key中,所有域与其值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field</span><br></pre></td></tr></table></figure></p><p>作用: 删除key中所有field域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure></p><p>作用: 返回key中元素的数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure></p><p>作用: 判断key中有没有field域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinrby key field value</span><br></pre></td></tr></table></figure></p><p>作用: 把key中的field域的值<strong>增长整型值</strong>value。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinrby float  key field value</span><br></pre></td></tr></table></figure></p><p>作用: 把key中的field域的值<strong>增长浮点值</strong>value。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br></pre></td></tr></table></figure></p><p>作用: 返回key中所有的field。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kvals key</span><br></pre></td></tr></table></figure></p><p>作用: 返回key中所有的value。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以将redis中的hashes类型看成具有String key和String value的map容器。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis对于hashes 哈希类型的操作" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E5%AF%B9%E4%BA%8Ehashes-%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>redis对于order set有序集合的操作(第六部分)</title>
    <link href="http://yoursite.com/2018/02/06/redis%E5%AF%B9%E4%BA%8Eorder-set%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C(%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/06/redis对于order-set有序集合的操作(第六部分)/</id>
    <published>2018-02-06T08:59:16.000Z</published>
    <updated>2018-02-06T09:17:03.919Z</updated>
    
    <content type="html"><![CDATA[<p>说到有序集合，大家是不是有点困惑，集合和有序集合有什么区别呢？<br>所谓的有序集合就是比集合多啦一个score，这个就是有序集合能够有序进行排列的依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 value1 score2 value2 ..</span><br></pre></td></tr></table></figure></p><p>添加元素到有序集合key。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zadd stu 18 lily 19 hmm 20 lilei 21 lilei</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>把集合排序后,返回名次[start,stop]的元素。<br>默认是升续排列。<br>withscores 是把score也打印出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure></p><p>返回有序集合key中元素个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br></pre></td></tr></table></figure></p><p>查询member的排名(升续 0名开始)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrank key memeber</span><br></pre></td></tr></table></figure></p><p>查询 member的排名(降续 0名开始)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key value1 value2 ..</span><br></pre></td></tr></table></figure></p><p>作用: 删除集合中的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></p><p>作用: 按照socre来删除元素,删除score在[min,max]之间的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zremrangebyscore stu 4 10</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange stu 0 -1</span><br><span class="line">1) &quot;f&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure><p>作用: 按排名删除元素,删除名次在[start,end]之间的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zremrangebyrank stu 0 1</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange stu 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;e&quot;</span><br><span class="line">3) &quot;f&quot;</span><br><span class="line">4) &quot;g&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange key start stop</span><br></pre></td></tr></table></figure><p>作用:把集合降序排列,取名字[start,stop]之间的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore  key min max [withscores] limit offset N</span><br></pre></td></tr></table></figure></p><p>作用: 集合(升续)排序后,取score在[min,max]内的元素,并跳过 offset个, 取出N个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zadd stu 1 a 3 b 4 c 9 e 12 f 15 g</span><br><span class="line">(integer) 6</span><br><span class="line">redis 127.0.0.1:6379&gt; zrangebyscore stu 3 12 limit 1 2 withscores</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;e&quot;</span><br><span class="line">4) &quot;9&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure><p>返回score在[min,max] 区间内元素的数量。<br><em>**</em>难理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key1 [key2 ...] </span><br><span class="line">[WEIGHTS weight [weight ...]] </span><br><span class="line">[AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></table></figure></p><p>求key1,key2的交集,key1,key2的权重分别是 weight1,weight2<br>聚合方法用: sum |min|max；聚合的结果,保存在dest集合内。<br><strong>注意</strong>: weights ,aggregate如何理解?<br>如果有交集, 交集元素又有socre,score怎么处理?<br>Aggregate sum求score相加 , min 求最小score, max 求最大score。<br>另: 可以通过weigth设置不同key的权重, 交集时,socre * weights。<br>详见下例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zadd z1 2 a 3 b 4 c</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd z2 2.5 a 1 b 8 d</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange tmp 0 -1</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;4.5&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2 aggregate sum</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;4.5&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2 aggregate min</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2 weights 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;7&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说到有序集合，大家是不是有点困惑，集合和有序集合有什么区别呢？&lt;br&gt;所谓的有序集合就是比集合多啦一个score，这个就是有序集合能够有序进行排列的依据。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis对于order set有序集合的操作" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E5%AF%B9%E4%BA%8Eorder-set%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>redis对于set集合的操作(第五部分)</title>
    <link href="http://yoursite.com/2018/02/06/redis%E5%AF%B9%E4%BA%8Eset%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C(%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/06/redis对于set集合的操作(第五部分)/</id>
    <published>2018-02-06T07:34:32.000Z</published>
    <updated>2018-02-06T07:41:47.345Z</updated>
    
    <content type="html"><![CDATA[<p>说到集合，大家肯定不陌生，初中高中都学过。是不是呢???<br><strong>集合的性质</strong>: 唯一性,无序性,确定性。<br><strong>注</strong>: 在string和lists的命令中,可以通过range 来访问string中的某几个字符或某几个元素 ,但,因为<strong>集合的无序性,无法通过下标或范围来访问部分元素</strong>.因此想看元素,要么随机选一个,要么全选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key  value1 value2</span><br></pre></td></tr></table></figure></p><p>作用: 往集合key中增加元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></p><p>作用: 返回集合key中所有的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></p><p>作用: 返回集合中元素的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key  value1 value2</span><br></pre></td></tr></table></figure></p><p>作用: 删除集合key中值为 value1 value2的元素。<br>返回值: 忽略不存在的元素后,真正删除掉的元素的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br></pre></td></tr></table></figure></p><p>作用: 返回并删除集合中key中1个随机元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key</span><br></pre></td></tr></table></figure></p><p>作用: 返回集合key中,随机的1个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key  value</span><br></pre></td></tr></table></figure></p><p>作用: 判断value是否在key集合中。<br>是返回1,否返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source dest value</span><br></pre></td></tr></table></figure></p><p>作用:把source中的value删除,并添加到dest集合中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter  key1 key2 key3</span><br></pre></td></tr></table></figure></p><p>作用: 求出key1 key2 key3 三个集合中的交集,并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; sadd s1 0 2 4 6</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd s2 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd s3 4 8 9 12</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; sinter s1 s2 s3</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; sinter s3 s1 s2</span><br><span class="line">1) &quot;4&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinterstore dest key1 key2 key3</span><br></pre></td></tr></table></figure><p>作用: 求出key1 key2 key3 三个集合中的交集,并赋给dest。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sunion key1 key2.. Keyn</span><br></pre></td></tr></table></figure></p><p>作用: 求出key1 key2 keyn的并集,并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdiff key1 key2 key3</span><br></pre></td></tr></table></figure></p><p>作用: 求出key1与key2 key3的差集。即key1-key2-key3 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说到集合，大家肯定不陌生，初中高中都学过。是不是呢???&lt;br&gt;&lt;strong&gt;集合的性质&lt;/strong&gt;: 唯一性,无序性,确定性。&lt;br&gt;&lt;strong&gt;注&lt;/strong&gt;: 在string和lists的命令中,可以通过range 来访问string中的某几个字符或
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis对于set集合的操作" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E5%AF%B9%E4%BA%8Eset%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>应用题(1)</title>
    <link href="http://yoursite.com/2018/02/06/%E5%BA%94%E7%94%A8%E9%A2%98-1/"/>
    <id>http://yoursite.com/2018/02/06/应用题-1/</id>
    <published>2018-02-06T06:38:02.000Z</published>
    <updated>2018-02-06T07:07:30.474Z</updated>
    
    <content type="html"><![CDATA[<p>大家一起来思考一个问题：<br><strong>场景</strong>：1亿个用户，用户有频繁登录的，也有不经常登录的，每个用户登录，记为今天活跃，否则记为不活跃。<br>问题一：如何来记录用户登录信息。<br>问题二：如何来查询活跃用户(每周评出: 有奖活跃用户: 连续7天登录)。</p><p><strong>思路一</strong>:  </p><table><thead><tr><th style="text-align:center">Userid</th><th style="text-align:center">dt</th><th style="text-align:center">active</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2018-02-06</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2018-02-06</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">2018-02-06</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">2018-02-06</td><td style="text-align:center">1</td></tr></tbody></table><p>如果是放在表中, 结果1:表急剧增大,2:要用group ,sum运算,计算较慢</p><p><strong>思路二</strong>：<br>位图法 bit-map<br>log0206:    ‘011001……………0’<br>log0207:    ‘010010……………1’<br>log0208:    ‘011001……………0’<br>log0209:    ‘011000……………1’<br>……  </p><ol><li>记录用户登陆:<br>每天按日期生成一个位图, 用户登陆后,把user_id位上的bit值置为1</li><li>如何来查询活跃用户<br>把1周的位图  and 计算, 位上为1的,即是连续登陆的用户。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setbit mon 100000000 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit mon 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit mon 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit mon 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit thur 100000000 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit thur 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit thur 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit thur 8 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit wen 100000000 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit wen 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit wen 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit wen 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; bitop and res mon thur wen</span><br><span class="line">(<span class="built_in">integer</span>) 12500001</span><br></pre></td></tr></table></figure></li></ol><p>如上例,优点:</p><ol><li>节约空间, 1亿人每天的登陆情况,用1亿bit,约1200WByte,约10M 的字符就能表示</li><li>计算方便</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家一起来思考一个问题：&lt;br&gt;&lt;strong&gt;场景&lt;/strong&gt;：1亿个用户，用户有频繁登录的，也有不经常登录的，每个用户登录，记为今天活跃，否则记为不活跃。&lt;br&gt;问题一：如何来记录用户登录信息。&lt;br&gt;问题二：如何来查询活跃用户(每周评出: 有奖活跃用户: 连续7
      
    
    </summary>
    
      <category term="应用题" scheme="http://yoursite.com/categories/%E5%BA%94%E7%94%A8%E9%A2%98/"/>
    
    
      <category term="应用题| redis应用 | 位图应用 | 应用题1" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E9%A2%98-redis%E5%BA%94%E7%94%A8-%E4%BD%8D%E5%9B%BE%E5%BA%94%E7%94%A8-%E5%BA%94%E7%94%A8%E9%A2%981/"/>
    
  </entry>
  
  <entry>
    <title>redis对于List链表的操作(第四部分)</title>
    <link href="http://yoursite.com/2018/02/06/redis%E5%AF%B9%E4%BA%8Elist%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C(%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/06/redis对于list链表的操作(第四部分)/</id>
    <published>2018-02-06T04:52:19.000Z</published>
    <updated>2018-02-06T05:11:56.409Z</updated>
    
    <content type="html"><![CDATA[<p>L代表左边头 R代表右边尾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key value</span><br></pre></td></tr></table></figure></p><p>作用: 把值插入到链表头部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpop key</span><br></pre></td></tr></table></figure></p><p>作用: 返回并删除链表尾元素。<br>rpush,lpop: 不解释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange key start  stop</span><br></pre></td></tr></table></figure></p><p>作用: 返回链表中[start ,stop]中的元素。<br><strong>规律</strong>: 左数从0开始,右数从-1开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure></p><p>作用: 从key链表中删除 value值。<br><strong>注</strong>: 删除绝对值count个值为value后结束<br>Count&gt;0 从表头删除<br>Count&lt;0 从表尾删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltrim key start stop</span><br></pre></td></tr></table></figure><p>作用: 剪切key对应的链表,切[start,stop]一段,并把该段重新赋给。key。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure></p><p>作用: 返回index索引上的值。<br>如  lindex key 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure></p><p>作用:计算链表的元素个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; llen task</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linsert  key after|before search value</span><br></pre></td></tr></table></figure><p>作用: 在key链表中寻找’search’,并在search值之前|之后,插入value<br><strong>注</strong>: 一旦找到一个search(如果有多个值，找到第一个)后,命令就结束了,因此不会插入多个value。</p><h5 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpoplpush source dest</span><br></pre></td></tr></table></figure><p>作用: 把source的尾部拿出,放在dest的头部,并返回该单元值。<br><strong>场景</strong>: task + bak 双链表完成安全队列。<br><strong>业务逻辑</strong>:</p><ol><li>Rpoplpush task bak；</li><li>接收返回值,并做业务处理；</li><li>如果成功,rpop bak 清除任务。 如不成功,下次从bak表里取任务。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brpop | blpop  key timeout</span><br></pre></td></tr></table></figure><p>作用:等待弹出key的尾/头元素。<br>Timeout为等待超时时间<br>如果timeout为0,则一直等待</p><p><strong>场景</strong>: 长轮询Ajax,在线聊天时,能够用到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;L代表左边头 R代表右边尾&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis对于list链表的操作" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E5%AF%B9%E4%BA%8Elist%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>redis对于String的操作(第三部分)</title>
    <link href="http://yoursite.com/2018/02/06/redis%E5%AF%B9%E4%BA%8EString%E7%9A%84%E6%93%8D%E4%BD%9C(%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/06/redis对于String的操作(第三部分)/</id>
    <published>2018-02-06T02:07:12.000Z</published>
    <updated>2018-02-06T02:37:30.965Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex 秒数] / [px 毫秒数]  [nx] /[xx]</span><br></pre></td></tr></table></figure><p>如: set a 1 ex 10 , 设置a的有效期为10秒<br>   set a 1 px 9000 , 设置a的有效期为9秒(9000毫秒)<br><strong>注</strong>: 如果ex,px同时写,以px有效期为准<br>如 set a 1 ex 100 px 9000, a的实际有效期是9000毫秒<br>nx: 表示key不存在时,执行操作<br>xx: 表示key必须存在时,执行操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset  multi set</span><br></pre></td></tr></table></figure></p><p>一次性设置多个键值<br>例: mset key1 v1 key2 v2 ….<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></p><p>作用:获取key的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2 ..keyn</span><br></pre></td></tr></table></figure></p><p>作用:获取多个key的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offset value</span><br></pre></td></tr></table></figure></p><p>作用:把字符串的offset偏移字节,改成value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set greet hello</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; setrange greet 2 ??</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; get greet</span><br><span class="line">&quot;he??o&quot;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>: 如果偏移量&gt;字符长度, 该字符自动补0x00<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setrange greet 6 !</span><br><span class="line">(integer) 7</span><br><span class="line">redis 127.0.0.1:6379&gt; get greet</span><br><span class="line">&quot;heyyo\x00!&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><p>作用: 把value追加到key的原值上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getrange key start stop</span><br><span class="line">redis 127.0.0.1:6379&gt; set title &apos;chinese&apos;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; getrange title 0 3</span><br><span class="line">&quot;chin&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; getrange title 1 -2</span><br><span class="line">&quot;hines&quot;</span><br></pre></td></tr></table></figure></p><p>作用: 是获取字符串中 [start, stop]范围的值<br><strong>注意</strong>: 对于字符串的下标,左数从0开始,右数从-1开始</p><ol><li>start&gt;=length, 则返回空字符串</li><li>stop&gt;=length,则截取至字符结尾</li><li>如果start 所处位置在stop右边, 返回空字符串  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getset key newvalue</span><br><span class="line">redis 127.0.0.1:6379&gt; set cnt 0</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; getset cnt 1</span><br><span class="line">&quot;0&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; getset cnt 2</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>作用: 获取并返回旧值,设置新值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure></p><p>作用: 指定的key的值加1,并返回加1后的值<br><strong>注意</strong>：</p><ol><li>不存在的key当成0,再incr操作</li><li>范围为64有符号  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrby key number</span><br><span class="line">redis 127.0.0.1:6379&gt; incrby age  90</span><br><span class="line">(integer) 92</span><br></pre></td></tr></table></figure><p>作用: 指定的key的值加number,并返回加number后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrbyfloat key floatnumber</span><br><span class="line">redis 127.0.0.1:6379&gt; incrbyfloat age 3.5</span><br><span class="line">&quot;95.5&quot;</span><br></pre></td></tr></table></figure></p><p>作用: 指定的key的值加浮点数,并返回加浮点数后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br><span class="line">redis 127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; decr age</span><br><span class="line">(integer) 19</span><br><span class="line">decrby key number</span><br><span class="line">redis 127.0.0.1:6379&gt; decrby age 3</span><br><span class="line">(integer) 16</span><br></pre></td></tr></table></figure></p><p>作用：和incr，incrby正好相反，这里不再多说。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line">redis 127.0.0.1:6379&gt; set char A</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; getbit char 1</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; getbit char 2</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; getbit char 7</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p><p>作用:获取值的二进制表示,对应位上的值(从左,从0编号)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit  key offset value</span><br></pre></td></tr></table></figure></p><p>作用：设置offset对应二进制位上的值<br>返回: 该位上的旧值<br><strong>注意</strong>:  </p><ol><li>如果offset过大,则会在中间填充0,</li><li>offset最大大到多少</li><li>offset最大2^32-1,可推出最大的的字符串为512M  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop operation destkey key1 [key2 ...]</span><br></pre></td></tr></table></figure><p>对key1,key2..keyN作operation,并将结果保存到 destkey 上。<br>operation 可以是 AND 、 OR 、 NOT 、 XOR<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setbit lower 7 0</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit lower 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get lower</span><br><span class="line">&quot; &quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; set char Q</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get char</span><br><span class="line">&quot;Q&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; bitop or char char lower</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; get char</span><br><span class="line">&quot;q&quot;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>: 对于NOT操作, key不能多个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis对于String的操作" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E5%AF%B9%E4%BA%8EString%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>redis对于key的通用操作(第二部分)</title>
    <link href="http://yoursite.com/2018/02/05/redis%E5%AF%B9%E4%BA%8Ekey%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C(%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/05/redis对于key的通用操作(第二部分)/</id>
    <published>2018-02-05T08:34:54.000Z</published>
    <updated>2018-02-05T08:49:26.363Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key1 key2 ... Keyn</span><br></pre></td></tr></table></figure><p>作用:删除1个或多个键<br>返回值: 不存在的key忽略掉,返回真正删除的key的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br></pre></td></tr></table></figure></p><p>作用: 给key赋一个新的key名<br><strong>注</strong>:如果newkey已存在,则newkey的原值被覆盖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renamenx key newkey</span><br></pre></td></tr></table></figure></p><p>作用: 把key改名为newkey<br>返回值: 发生修改返回1,未发生修改返回0<br><strong>注</strong>: nx–&gt; not exists, 即, newkey不存在时,作改名动作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379[1]&gt; select 2</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379[2]&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">redis 127.0.0.1:6379[2]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;cc&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; move cc 2</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; select 2</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379[2]&gt; keys *</span><br><span class="line">1) &quot;cc&quot;</span><br><span class="line">redis 127.0.0.1:6379[2]&gt; get cc</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>(注意: 一个redis进程,打开了不止一个数据库, 默认打开16个数据库,从0到15编号,如果想打开更多数据库,可以从配置文件修改)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure></p><p>作用:查询相应的key<br>在redis里,允许模糊查询key,有3个通配符 *, ? ,[]</p><ol><li>*: 通配任意多个字符</li><li>?: 通配单个字符</li><li>[]: 通配括号内的某1个字符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">redis 127.0.0.1:6379&gt; mset one 1 two 2 three 3 four 4</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; keys o*</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; keys *o</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; keys ???</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; keys on?</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; set ons yes</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; keys on[eaw]</span><br><span class="line">1) &quot;one&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure><p>作用:返回随机key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure></p><p>作用:判断key是否存在,返回1(存在)/0(不存在)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></p><p>作用:返回key存储的值的类型<br>有string,link,set,order set, hash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure></p><p>作用: 查询key的生命周期<br>返回: 秒数<br>注:对于不存在的key或已过期的key,返回-2<br>  对于存在的key,返回-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key 整型值</span><br></pre></td></tr></table></figure></p><p>作用: 设置key的生命周期,以秒为单位<br>同理:<br>pexpire key 毫秒数, 设置生命周期<br>pttl  key, 以毫秒返回生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure><p>作用: 把指定key置为永久有效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis对于key的通用操作" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E5%AF%B9%E4%BA%8Ekey%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>redis的特点及安装(第一部分)</title>
    <link href="http://yoursite.com/2018/02/05/redis%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E5%AE%89%E8%A3%85(%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86)/"/>
    <id>http://yoursite.com/2018/02/05/redis的特点及安装(第一部分)/</id>
    <published>2018-02-05T02:45:54.000Z</published>
    <updated>2018-02-08T03:35:35.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>2017年已经接近尾声，最近自己在慧与实习(原惠普)也没啥事，闲暇之余，想起自己已经好久没有写博客，决定把redis的博客稍微写一写，相当于做一份笔记，以后方便查阅。</p><h4 id="redis是啥呢"><a href="#redis是啥呢" class="headerlink" title="redis是啥呢"></a>redis是啥呢</h4><p><a href="https://redis.io/" target="_blank" rel="external">redis的官方站点</a></p><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries.</p><p>redis是开源(BSD许可),内存数据结构存储.可以当作数据库，缓存和信息代理使用。它支持的数据结构服务，有字符串、哈希表、列表、集合、有序集合范围查询，位图，hyperloglogs和半径查询地理信息的索引。</p><h4 id="redis和memcached的简单比较"><a href="#redis和memcached的简单比较" class="headerlink" title="redis和memcached的简单比较"></a>redis和memcached的简单比较</h4><p>redis和memcached相比,独特之处:</p><ol><li><p>redis可以用来做存储(storge)和缓存(cache), 而memcached只可以用来做缓存(cache)。这个特点主要因为其有”持久化”的功能.<br><strong>持久化简单一句话就是内存里面数据可以同步到光盘或硬盘等长久可以存储的设备上面。</strong></p></li><li><p>存储的数据有”结构”,对于memcached来说,存储的数据,只有1种类型–”字符串”,而redis则可以存储字符串,链表,哈希结构,集合,有序集合.</p></li></ol><h4 id="redis下载安装"><a href="#redis下载安装" class="headerlink" title="redis下载安装"></a>redis下载安装</h4><ol><li>官方站点: <strong>redis.io</strong> 下载最新版或者最新stable版</li><li>解压源码并进入目录</li><li>不用configure(生成makefile)</li><li>直接make 编译(如果是32位机器 make 32bit;时间问题见末尾)</li><li>可选步骤: make test  测试编译情况<br>(可能出现: need tcl  &gt;8.4这种情况, yum install tcl)</li><li><p>make install安装到指定的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-4.0.8.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.8.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-4.0.8</span><br><span class="line">$ make</span><br><span class="line">$ make  PREFIX=/home/centos/redis/anzhuang install 注: PREFIX要大写</span><br></pre></td></tr></table></figure></li><li><p>make install之后,得到如下几个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark  性能测试工具</span><br><span class="line">redis-check-aof  日志文件检测工具(比如断电造成日志损坏,可以检测并修复)</span><br><span class="line">redis-check-dump  快照文件检测工具,效果类上</span><br><span class="line">redis-sentinel  哨兵，进行主从切换</span><br><span class="line">redis-cli  客户端</span><br><span class="line">redis-server 服务端</span><br></pre></td></tr></table></figure></li><li><p>复制配置文件(从redis的源码目录中复制redis.conf到redis的安装目录)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /path/redis.conf /home/centos/redis/anzhuang</span><br></pre></td></tr></table></figure></li><li><p>服务端启动与客户端连接(默认redis端口号为6379，启动方式为前台启动，就是服务端启动打开一个界面，不能关闭，重新开一个客户端界面进行连接)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd  /home/centos/redis/anzhuang/bin/</span><br><span class="line">./redis-server redis.conf  服务端启动</span><br><span class="line">./redis-cli [-h localhost -p 6379 ] 客户端连接</span><br></pre></td></tr></table></figure></li><li><p>让redis以后台进程的形式运行  </p><p>编辑conf配置文件,修改如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure></li></ol><p>至此，redis已经安装完成，是不是很简单呢？？Enjoy<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep redis  查看redis运行进程</span><br><span class="line">redis-cli shutdown  关闭redis服务</span><br><span class="line">/etc/init.d/redis-server start  启动redis</span><br><span class="line">/etc/init.d/redis-server stop  关闭redis</span><br><span class="line">/etc/init.d/redis-server restart  重启redis</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>:Make编译时易碰到的问题,时间错误.<br>原因: 源码是官方configure过的,但官方configure时,生成的文件有时间戳信息,<strong> Make只能发生在configure之后</strong><br>如果你的虚拟机的时间不对,比官方configure时间早<br>解决:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -s ‘yyyy-mm-dd hh:mm:ss’ 重写系统时间</span><br><span class="line">clock -w  把当前系统时间写入CMOS中</span><br></pre></td></tr></table></figure></p><h4 id="了解系统时间与CMOS时间关系"><a href="#了解系统时间与CMOS时间关系" class="headerlink" title="了解系统时间与CMOS时间关系"></a>了解系统时间与CMOS时间关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统时间由linux操作系统来维护，CMOS时间是CMOS芯片保存的时间。系统启动时，操作系统将从CMOS读出时间记录为系统时间，同时操作系统每隔一段时间自动将系统时间写入CMOS中，如果使用date命令修改完系统时间后立即重启电脑，操作系统还没有将系统时间写入CMOS中，这样开机后就还是修改前的时间，为了保险起见，建议手动使用命令clock将系统时间写入CMOS中。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;2017年已经接近尾声，最近自己在慧与实习(原惠普)也没啥事，闲暇之余，想起自己已经好久没有写博客，决定把redis的博客稍微写一写，相当于
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="教程| redis教程 | redis特点及安装" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-redis%E6%95%99%E7%A8%8B-redis%E7%89%B9%E7%82%B9%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--策略模式</title>
    <link href="http://yoursite.com/2017/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/15/设计模式-策略模式/</id>
    <published>2017-12-15T06:28:54.000Z</published>
    <updated>2017-12-15T08:09:16.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</span><br></pre></td></tr></table></figure><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/image/策略模式.png" alt="策略模式"></p><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><p>Duck：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Duck</span><br><span class="line">    &#123;</span><br><span class="line">        //为行为接口类型声明两个引用变量，所有鸭子子类都继承它们。</span><br><span class="line">        public IFlyBehavior flyBehavior;</span><br><span class="line">        //每只鸭子都引用实现QuackBehavior接口的对象。</span><br><span class="line">        public IQuackBehavior quackBehavior;</span><br><span class="line">        public <span class="function"><span class="title">Duck</span></span>() &#123; &#125;</span><br><span class="line">        public abstract void Display();</span><br><span class="line">        public void PerformFly()</span><br><span class="line">        &#123;</span><br><span class="line">            //委托给行为类</span><br><span class="line">            flyBehavior.Fly();</span><br><span class="line">        &#125;</span><br><span class="line">        public void PerformQuack()</span><br><span class="line">        &#123;</span><br><span class="line">            //鸭子将呱呱叫行为委托给quackBehavior引用的对象。</span><br><span class="line">            quackBehavior.Quack();</span><br><span class="line">        &#125;</span><br><span class="line">        public void Swim()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"会游泳....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>IFlyBehavior:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       //所有飞行行为必须实现的接口。</span><br><span class="line">       void Fly();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>IQuackBehavior:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       void Quack();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>FlyWithWings:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FlyWithWings : IFlyBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IFlyBehavior 成员</span></span><br><span class="line">       public void Fly()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"会飞......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>FlyNoWay:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FlyNoWay : IFlyBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IFlyBehavior 成员</span></span><br><span class="line">       public void Fly()</span><br><span class="line">       &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"不会飞......"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>MuteQuack:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MuteQuack : IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IQuackBehavior 成员</span></span><br><span class="line">       public void Quack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"不会叫"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Quack:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Quack : IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IQuackBehavior 成员</span></span><br><span class="line">       void IQuackBehavior.Quack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"呱呱叫......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Squeak:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Squeak : IQuackBehavior</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">#region IQuackBehavior 成员</span></span><br><span class="line">       public void Quack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"吱吱叫......."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">#endregion</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>MallardDuck:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MallardDuck : Duck</span><br><span class="line">   &#123;</span><br><span class="line">       public MallardDuck()</span><br><span class="line">        &#123;</span><br><span class="line">            //FlyWithWings作为IFlyBehavior类型</span><br><span class="line">            base.flyBehavior = new FlyWithWings();</span><br><span class="line">            //Quack类处理呱呱叫。</span><br><span class="line">            base.quackBehavior = new Quack();</span><br><span class="line">        &#125;</span><br><span class="line">       public override void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"绿头鸭......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>WoodDuck:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WoodDuck : Duck</span><br><span class="line">   &#123;</span><br><span class="line">       public WoodDuck()</span><br><span class="line">        &#123;</span><br><span class="line">            flyBehavior = new FlyNoWay();</span><br><span class="line">            quackBehavior = new MuteQuack();</span><br><span class="line">        &#125;</span><br><span class="line">       public override void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"木头鸭子....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Main:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">   &#123;</span><br><span class="line">       static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           Duck mallard = new MallardDuck();</span><br><span class="line">           mallard.Display();</span><br><span class="line">           //调用MallardDuck继承来的perform方法，进而将绿头鸭的行为委托给quack和fly的行为类来处理。</span><br><span class="line">           mallard.PerformFly();</span><br><span class="line">           mallard.PerformQuack();</span><br><span class="line">           mallard.Swim();</span><br><span class="line">           Duck wood = new WoodDuck();</span><br><span class="line">           wood.Display();</span><br><span class="line">           wood.PerformFly();</span><br><span class="line">           wood.PerformQuack();</span><br><span class="line">           wood.Swim();</span><br><span class="line">           Console.Read();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/image/运行结果1.png" alt="策略模式运行结果"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>00基础</strong></p><ul><li>抽象</li><li>继承</li><li>多态</li><li>封装</li></ul><p><strong>00原则</strong></p><ul><li>封装变化</li><li>多用组合，少用继承。<br>使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。</li><li>针对接口编程，不针对实现编程</li></ul><p><strong>优点</strong></p><p>1、 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。</p><p>2、 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。</p><p>3、 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。</p><p><strong>缺点</strong></p><p>1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</p><p>2、 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。[不很清楚]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h3&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="教程| 设计模式教程 | 设计模式--策略模式" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客后端管理工具---hexo-admin</title>
    <link href="http://yoursite.com/2017/12/15/hexo%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-hexo-admin/"/>
    <id>http://yoursite.com/2017/12/15/hexo博客后端管理工具-hexo-admin/</id>
    <published>2017-12-15T03:15:00.000Z</published>
    <updated>2017-12-15T05:49:27.402Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近又重新折腾和整理啦一下自己的博客，发现每次写博客都会进入<code>修改-&gt;启动hexo server-&gt;修改</code>的回圈，这是一个非常麻烦的过程，有没有好的解决方案呢？？？困惑？肯定有呀！！也就是我接下来要介绍的<a href="https://jaredforsyth.com/hexo-admin/" target="_blank" rel="external">hexo-admin</a></p><p><img src="/image/hexo.jpg" alt="“hexo-admin”"> </p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>hexo-admin 这款插件的安装也非常简单，通过简单的npm就可以一键安装啦。进入搭建好的博客目录，执行安装指令，启动hexo的server，在本地就可以进行文章的管理与发布啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexohexo</span><br><span class="line">npm install -save hexo-admin</span><br><span class="line">hexo server -d</span><br><span class="line">open http://localhost:4000/admin/</span><br></pre></td></tr></table></figure><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>其实我是边写这篇博客，边了解这个插件功能的，发现很多优点：</p><ul><li><p><strong>即时保存</strong><br>在网页上直接写博客，不用进行额外的保存。这款插件会每隔几秒钟就会自动保存一次，再也不怕忘记保存啦。但是习惯了常常默认按ctrl+s来保存，变成了保存网页，哈哈。<br>我们可以发现目录架构中增加了两个文件夹，hexo-admin在原来hexo的基础上加入了draft和discarded来保存我们的草稿和删除的markdown。不用怕误删，也不用怕自己没写好的草稿，不小心就发布出去啦。</p></li><li><p><strong>即时渲染</strong><br>会发现如果你是在修改当前页面的markdown文件，server上也会动态发生效果，就可以发现效果已经变啦。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>2017年已经接近尾端，一个晴朗的白天，放下作业，整理一下自己的思绪，写写总结。无意中间发现这么一款管理博客的神器，也是蛮开心的！以后自己写东西也会方便很多！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"><br></iframe>  ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近又重新折腾和整理啦一下自己的博客，发现每次写博客都会进入&lt;code&gt;修改-&amp;gt;启动hexo server-&amp;gt;修改&lt;/code&gt;
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="教程| Hexo教程 | Hexo博客后端管理工具" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-Hexo%E6%95%99%E7%A8%8B-Hexo%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程核心技术----java多线程技能</title>
    <link href="http://yoursite.com/2017/11/12/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E8%83%BD/"/>
    <id>http://yoursite.com/2017/11/12/java多线程编程核心技术-java多线程技能/</id>
    <published>2017-11-12T05:28:31.000Z</published>
    <updated>2017-11-12T07:44:39.007Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>进程</strong>：通过查看“windows任务管理器”中的列表，完全可以将运行在内存中的exe文件理解成进程。</p><p>进程是受操作系统管理的基本运行单元。</p><p><strong>线程</strong>：线程可以理解成是在进程中独立运行的子任务。比如，QQ.exe运行时就有很多的子任务在同时运行。</p><p>那么，使用多线程有什么优点呢？</p><p>单线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，任务2必须等任务1执行完10秒之后才能执行。</p><p> 特点：排队执行，即同步，CPU利用率大幅降低。</p><p>多线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，CPU完全可以在任务1和任务2之间来回切换，使任务2不必等待10秒再运行。</p><p> 特点：在使用异步，系统的运行效率得到大幅度提升。</p><p>多线程是异步的，所以千万不要把Eclipse里代码的顺序当成线程的执行顺序，线程被调用的时机是随机的。</p><p>一个进程在运行时至少有一个线程在运行，比如在Java中，调用<code>public static void main()</code>方法就会创建一个线程，名字叫main（这个main和main方法名字没有任何关系），而且它是由JVM创建的。</p><h4 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h4><p>实现多线程编程有两种主要方式：一种是继承Thread类，另一种是实现Runnable接口。都是重写<code>run</code>方法。（java支持单继承）</p><p> Thread.java类也实现啦Runnable接口</p><p>Thread.java类中的start()方法通知“线程规划池”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。</p><p>thread.run()方法而是同步，此线程对象并不交给“线程规划器”来进行处理，而是由main主线程来调用run()方法，也就是必须等待run()方法中的代码执行完之后才可以执行后面代码。</p><p>执行start()方法的顺序并不代表线程启动的顺序。</p><p>非线程安全：多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改，值不同步的情况，进而影响程序的执行流程。（使用synchronized关键字加锁）</p><p>留意i++与System.out.println()的异常：使用<code>System.out.println(&quot;i=&quot;+(i++))</code><br>虽然println()方法内部是同步的，但i++的操作却是在进入println()之前发生的，所以有发生非线程安全问题的概率。</p><p>currentThread()方法：返回代码段正在被哪个线程调用的信息。</p><p>isAlive()方法：判断当前线程是否处于活动状态。</p><p>sleep()方法：在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指<code>this.currentThread()</code>返回的线程。</p><p>getId()方法：获取线程的唯一标识。</p><p>yield()方法：放弃当前的CPU资源，将它让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。</p><h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程正常退出，即run()方法完成后线程终止。</span><br><span class="line">使用stop()方法强行终止线程。（不推荐使用）</span><br><span class="line">使用interrupt方法中断线程。（还需要加入一个判断才可以完成线程----抛出异常，break，return）</span><br></pre></td></tr></table></figure><p>判断线程是否是停止状态：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.interrupted():测试当前线程是否已经是中断状态，执行后具有将状标志置清除为false的功能。当前线程是指运行this.interrupted()方法的线程。</span><br><span class="line"></span><br><span class="line">this.isInterrupted():测试线程Thread对象是否已经是中断状态，但不清除状态标志。</span><br></pre></td></tr></table></figure><h4 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h4><p>使用<code>suspend()</code>方法暂停线程，使用<code>resume()</code>方法恢复线程的执行。</p><p>缺点：独占，不同步</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。</p><p>设置线程优先级有助于帮“线程规划器”确定在下一次选择哪个线程来优先执行。</p><p>线程优先级分为<code>1~10</code>这10个等级，如果小于1或大于10，则JDK抛出异常<code>throw new IllegalArgumentException()</code>,</p><p>JDK使用3个常量来预置定义优先级的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static int MIN_PRIORITY = 1;</span><br><span class="line">public final static int NORM_PRIORITY = 5;</span><br><span class="line">public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure><p> 线程优先级具有继承性：A线程启动B线程，则B线程的优先级与A一样。</p><p> 高优先级的线程总是<code>大部分</code>先执行完，但不代表高优先线程全部先执行完。</p><p> 线程的优先级与代码的执行顺序无关。</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p> 在java线程中有两种线程，一种是用户线程，另一种是守护线程。</p><p> 任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，当进程中不存在非守护线程了，则守护线程自动销毁。</p><p> 典型的守护线程是：GC（垃圾回收器）</p><p> <code>thread.setDaemon(true)</code>：设置当前线程为守护线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：通过查看“windows任务管理器”中的列表，完全可以将运行在内存中的exe文件理解成进程。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java多线程编程核心技术| java多线程技能" scheme="http://yoursite.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="java多线程编程核心技术" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客源文件备份</title>
    <link href="http://yoursite.com/2017/11/11/Hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    <id>http://yoursite.com/2017/11/11/Hexo博客源文件备份/</id>
    <published>2017-11-11T04:49:00.000Z</published>
    <updated>2017-12-15T08:17:59.847Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用Hexo编写博客还是比较Nice的，但是有一个问题就是Hexo博客的源文件是放在本地的，如果换一台电脑更新博客或者源文件不小心丢失啦，那就麻烦啦。未雨绸缪，现在给出这一问题的解决方案。</p><h4 id="备份方案"><a href="#备份方案" class="headerlink" title="备份方案"></a>备份方案</h4><p>想到的办法：</p><ul><li><p>将博客源文件拷贝到U盘里—但是这样做，无法同步。</p></li><li><p>使用网盘的话，据说.git文件不能上传同步—而且我对国内的网盘也不放心。</p></li></ul><p>综合起来，我觉得比较流行的方法就是：</p><ul><li>将博客源文件托管到Github.</li></ul><h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><ul><li><p>在Github上创建一个新的repository ,名字为<code>hexohexo</code>。（与你的本地博客源文件文件名相同即可）</p></li><li><p>进入本地<code>hexohexo</code>文件夹,执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置远程仓库地址，并更新，本地文件夹与远程仓库绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:hanweizhe/hexohexo.git</span><br><span class="line">git pull orgin master</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>(<strong>非必须项</strong>) 修改<code>.gitignore</code>文件（如果没有就手动创建一个），在里面加入<code>.*.log</code>和<code>public/</code>以及<code>.deploy*/</code>。因为每次执行<code>hexo generate</code>命令时，上述目录都会被重写更新，因此忽略上述目录下的文件更新，加快push速度。</p></li><li><p>完成Hexo源码在本地的提交，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"添加Hexo源码文件作为备份"</span></span><br></pre></td></tr></table></figure></li><li><p>将本地仓库文件推送到Github，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>当远程仓库有更新时，执行以下命令，即可同步远程源代码文件到本地文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li></ul><p>现在在任何一台电脑上，只需要<code>git clone git@github.com:hanweizhe/hexoohexo.git</code> 即可将Hexo源文件复制到本地。（请将<code>git clone git@github.com:hanweizhe/hexohexo.git</code> 换成自己远程仓库地址）</p><p>在本地编写完博客时，顺序执行以下命令，即可完成Hexo博客源文件的同步更新，保持Github上的Hexo源码为最新的版本。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"更新Hexo源文件"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>至此，Hexo源代码文件就完成了同步与更新。</p><p>对于博主这种懒人，每次更新博文都需要输入两三行重复的git命令真是一件麻烦事，说不定哪天就忘记push到Github上啦。有没有更省事的办法？？完成自动备份 ？？</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用<code>NodeJs</code>的事件监听机制实现监听Hexo的<code>deployAfter</code>事件，待博客部署完成之后自动运行Git备份命令，以达到自动备份的目的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="将hexohexo目录加入Git仓库（见前面）。"><a href="#将hexohexo目录加入Git仓库（见前面）。" class="headerlink" title="将hexohexo目录加入Git仓库（见前面）。"></a>将hexohexo目录加入Git仓库（见前面）。</h5><h5 id="安装shelljs模块。"><a href="#安装shelljs模块。" class="headerlink" title="安装shelljs模块。"></a>安装<code>shelljs</code>模块。</h5><p>要实现这个自动备份功能，需要依赖NodeJs的一个<code>shelljs</code>模块，该模块重新包装啦<code>child_process</code><br> ,调用系统命令更加方便。该模块需要安装后使用。</p><p>键入以下命令，完成<code>shelljs</code>模块的安装：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save shelljs</span><br></pre></td></tr></table></figure><h5 id="编写自动备份脚本"><a href="#编写自动备份脚本" class="headerlink" title="编写自动备份脚本"></a>编写自动备份脚本</h5><p>待到模块安装完成，在<code>hexohexo</code>根目录的<code>scripts</code>文件夹下新建一个js文件，文件名字随意取。</p><p><strong>如果没有<code>scripts</code>目录，请新建一个。</strong></p><p>然后再脚本中，写入以下内容：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       hexo.on(<span class="string">'deployAfter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//当   deploy完成后执行备份</span></span><br><span class="line">           run();</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为："</span> + e.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!which(<span class="string">'git'</span>)) &#123;</span><br><span class="line">           echo(<span class="string">'Sorry, this script requires git'</span>);</span><br><span class="line">           exit(<span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           echo(<span class="string">"======================Auto Backup Begin==========================="</span>);</span><br><span class="line">           cd(<span class="string">'D:/hexohexo'</span>);    <span class="comment">//此处修改为   Hexo根目录路径</span></span><br><span class="line">           <span class="keyword">if</span> (exec(<span class="string">'git add --all'</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">               echo(<span class="string">'Error: Git add failed'</span>);</span><br><span class="line">               exit(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (exec(<span class="string">'git commit -am "Form auto backup script\'s commit"'</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">               echo(<span class="string">'Error: Git commit failed'</span>);</span><br><span class="line">               exit(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (exec(<span class="string">'git push origin master'</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">               echo(<span class="string">'Error: Git push failed'</span>);</span><br><span class="line">               exit(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           echo(<span class="string">"==================Auto Backup Complete============================"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>其中，需要修改地<code>15</code>行的<code>D:/hexohexo</code>路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径）；</li><li>如果你的Git远程仓库名称不为<code>origin</code>的话（默认为<code>origin</code>），还需要修改第<code>24</code>行执行的push命令，修改成自己的远程仓库名与相应的分支名。</li></ul><p>保存脚本并退出，然后执行<code>hexo deploy</code>命令，将会得到类似以下结果：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: git&gt;</span><br><span class="line">INFO  Clearing .deploy folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">[master 3020788] Site updated: 2015-07-06 15:08:06</span><br><span class="line"> 5 files changed, 160 insertions(+), 58 deletions(-)</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch gh-pages from git@github.com:smilexi</span><br><span class="line">amo/notes.git.</span><br><span class="line">To git@github.com:smilexiamo/notes.git</span><br><span class="line">   02adbe4..3020788  master -&gt; gh-pages</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch gitcafe-pages from git@gitcafe.com:s</span><br><span class="line">milexiamo/smilexiamo.git.</span><br><span class="line">To git@gitcafe.com:smilexiamo/smilexiamo.git</span><br><span class="line">   02adbe4..3020788  master -&gt; gitcafe-pages</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br><span class="line">======================Auto Backup Begin===========================</span><br><span class="line">[master f044360] Form auto backup script<span class="string">'s commit</span></span><br><span class="line"><span class="string"> 2 files changed, 35 insertions(+), 2 deletions(-)</span></span><br><span class="line"><span class="string"> rewrite db.json (100%)</span></span><br><span class="line"><span class="string">To git@github.com:smilexiamo/hexo.git</span></span><br><span class="line"><span class="string">   8f2b4b4..f044360  master -&gt; master</span></span><br><span class="line"><span class="string">==================Auto Backup Complete============================</span></span><br></pre></td></tr></table></figure><p>这样子，每次更新博客并<code>hexo deploy</code>到服务器上之后。备份就会自动启动并完成备份啦！~~~ 是不是很方便呀！</p><p>Enjoy it!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;使用Hexo编写博客还是比较Nice的，但是有一个问题就是Hexo博客的源文件是放在本地的，如果换一台电脑更新博客或者源文件不小心丢失啦，那
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="教程| Hexo教程 | Hexo源文件备份" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B-Hexo%E6%95%99%E7%A8%8B-Hexo%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
</feed>
